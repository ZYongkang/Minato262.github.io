<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[目录]]></title>
    <url>%2F2019%2F07%2F01%2Fkaywu%2F</url>
    <content type="text"><![CDATA[一，计算机科学1，理论计算机&emsp;1.1 高等数学&emsp;1.2 数据结构与算法&emsp;1.3 计算机理论&emsp;1.4 信息论与编程理论&emsp;1.5 编程语言和编译器&emsp;1.6 形式化方法 2，计算机系统&emsp;2.1 计算机体系结构与计算机工程&emsp;2.2 操作系统&emsp;2.3 并发、并行与分布式系统&emsp;2.4 计算机网络&emsp;2.5 计算机安全与密码学&emsp;2.6 数据库 3，计算机应用技术&emsp;3.1 计算机图形学&emsp;3.2 科学计算&emsp;3.3 多媒体技术&emsp;3.4 人工智能 二，软件工程1，编程思想&emsp;1.1 Unix 编程思想&emsp;1.2 简约设计&emsp;1.3 设计模式解析 2，编程语言&emsp;2.1 Java&emsp;&emsp;1) jvm 原理&emsp;&emsp;2) java 并发&emsp;&emsp;3) spring 源码分析&emsp;&emsp;4) mybaits 源码分析&emsp;2.2 Python&emsp;2.3 C&emsp;&emsp;1) 基于c 编写编程语言 3，常用中间件&emsp;3.1 mysql&emsp;3.1 ES&emsp;3.2 redis&emsp;3.3 kafka&emsp;3.4 rabbitMQ 三，其他&emsp;1 技术积累&emsp;2 个人随笔&emsp;3 书单及资料&emsp;4 源码库&emsp;5 编程规范]]></content>
  </entry>
  <entry>
    <title><![CDATA[应用数学]]></title>
    <url>%2F2019%2F07%2F01%2F1%2F1.1_math%2Fmath%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 简介 2 基本数学2.1 基本思想&emsp; 2.1.1 二进制&emsp; 2.1.2 取余&emsp; 2.1.3 迭代法&emsp; 2.1.4 数学归纳法&emsp; 2.1.5 递归&emsp; 2.1.6 排序&emsp; 2.1.7 组合&emsp; 2.1.8 动态规划&emsp; 2.1.9 树&emsp; 2.1.10 图&emsp; 2.1.11 总结 2.2 数据结构与算法&emsp; 2.2.1 时间和空间复杂度 2.3 常用数据结构&emsp; 2.3.1 数组&emsp; 2.3.2 链表（LRU 算法）&emsp; 2.3.3 栈&emsp; 2.3.4 队列&emsp; 2.3.5 离散表&emsp; 2.3.6 二叉树&emsp;&emsp; 1) 二叉树&emsp;&emsp; 2) B- 树&emsp;&emsp; 3) B+ 树&emsp;&emsp; 4) 红黑树&emsp; 2.3.7 堆&emsp; 2.3.8 跳表&emsp; 2.3.9 图&emsp; 2.3.10 Trie 树&emsp; 2.4.11 总结 2.4 常用算法&emsp; 2.4.1 递归&emsp; 2.4.2 排序&emsp; 2.4.3 二分查找&emsp; 2.4.4 搜索&emsp; 2.4.5 哈希算法&emsp; 2.4.6 贪心算法&emsp; 2.4.7 分治算法&emsp; 2.4.8 回溯算法&emsp; 2.4.9 动态规划&emsp; 2.4.10 匹配算法&emsp; 2.4.11 总结 3 高等数学3.1 线性代数&emsp; 3.1.1 线性代数应用&emsp; 3.1.2 向量空间（可用于大数据检索）&emsp; 3.1.3 文本检索（可用于自然语言）&emsp; 3.1.4 矩阵（可用于推荐算法）&emsp; 3.1.5 线性回归（可用于机器学习）&emsp; 3.1.6 PAC 主成分分析（可用于机器学习）&emsp; 3.1.7 奇异值分解&emsp; 3.1.8 总结 3.2 统计数学&emsp; 3.2.1 概率与统计&emsp; 3.2.2 概率基础&emsp; 3.2.3 朴素贝叶斯（可用于过滤垃圾短信）&emsp; 3.2.4 文本分类（可用于潜在语义分析）&emsp; 3.2.5 文本聚类（可用于潜在语义分析）&emsp; 3.2.6 语言模型（可用于机器学习）&emsp; 3.2.7 马贝尔科夫链（可用于机器学习）&emsp; 3.2.8 信息熵（可用于自然语言）&emsp; 3.2.9 决策树&emsp; 3.2.10 熵、信息增益和卡方（可用于自然语言）&emsp; 3.2.11 规划和标准化（可用于机器学习）&emsp; 3.2.12 特征选择和降维（可用于机器学习）&emsp; 3.2.13 总结 3.3 离散数学3.4 组合数学3.5 高阶数据结构与算法&emsp; 3.5.1 拓扑排序&emsp; 3.5.2 最短路径算法（可用于地图规划）&emsp; 3.5.3 位图（可用于爬虫）&emsp; 3.5.4 统计问题&emsp; 3.5.5 向量空间（可用于推荐和检索）&emsp; 3.5.6 索引（可用于实现各种索引）&emsp; 3.5.7 并行算法&emsp; 3.5.8 总结 4 应用&emsp; 4.1 缓存系统&emsp; 4.2 搜索引擎&emsp; 4.3 推荐系统&emsp; 4.4 总结]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 概述&emsp;1.2 并行编程模型&emsp;1.3 Java 中的锁与线程模型 2 原理2.1 线程&emsp;2.1.1 线程的定义&emsp;2.1.2 线程的层次&emsp;2.1.3 线程创建后的相关行为&emsp;2.1.4 应用程序设计模型与多线程技术&emsp;2.1.5 虚拟环境：虚拟机与虚拟平台 2.2 锁与同步代码块&emsp;2.2.1 并发底层实现原理&emsp;2.2.2 Java 对象头&emsp;2.2.3 锁以及锁升级&emsp;2.2.4 原子操作的实现原理&emsp;2.2.5 综述 2.3 JMM&emsp;2.3.1 简介&emsp;2.3.2 基础&emsp;2.3.3 重排序&emsp;2.3.4 顺序一致性&emsp;2.3.5 volatile 内存模型&emsp;2.3.6 锁 内存模型&emsp;2.3.7 final 内存模型&emsp;2.3.8 happens-before&emsp;2.3.9 综述 2.4 线程安全&emsp;2.4.1 原子性&emsp;2.4.2 锁机制&emsp;2.4.3 可见性&emsp;2.4.4 线程封闭&emsp;2.4.5 不变性&emsp;2.4.6 组合&emsp;2.4.7 综述 2.5 常见并发问题及解决方案&emsp;2.5.1 线程过多&emsp;2.5.2 数据竞争、死锁和活锁&emsp;2.5.3 锁竞争&emsp;2.5.4 非阻塞算法&emsp;2.5.5 线程安全函数和库&emsp;2.5.6 存储问题&emsp;2.5.7 cache 相关&emsp;2.5.8 面向高性能数据组织 3 并行程序设计3.1 多线程基础&emsp;3.1.1 任务分解&emsp;3.1.2 数据分解&emsp;3.1.3 数据流分解&emsp;3.1.4 各种分解方式比较&emsp;3.1.5 综述 3.2 并行程序结构设计&emsp;3.2.1 同步&emsp;3.2.2 临界段&emsp;3.2.3 死锁&emsp;3.2.4 同步原语&emsp;&emsp;1）信号量&emsp;&emsp;2）闭锁&emsp;&emsp;3）条件变量&emsp;3.2.5 消息&emsp;3.2.6 流控&emsp;&emsp;1）栅栏&emsp;&emsp;2）栅障&emsp;3.2.7 其他特征&emsp;3.2.8 综述 3.3 并行程序模式&emsp;3.3.1 单线程模式&emsp;3.3.2 不变模式&emsp;3.3.3 保护性暂挂模式&emsp;3.3.4 回避模式&emsp;3.3.5 生产消费模式&emsp;3.3.6 读写锁模式&emsp;3.3.7 单线程消息模式&emsp;3.3.8 线程池模式 3.4 并行模型&emsp;3.4.1 Actor 模型 4 应用4.1 并发编程基础&emsp;4.1.1 线程简介&emsp;4.1.2 线程应用&emsp;4.1.3 线程同步&emsp;4.1.4 线程通信&emsp;4.1.5 综述 4.2 并发包&emsp;4.2.1 简介&emsp;4.2.2 锁机制&emsp;4.2.3 原子变量&emsp;4.2.4 并发集合&emsp;4.2.5 非阻塞队列&emsp;4.2.6 阻塞队列&emsp;4.2.7 同步辅助工具&emsp;4.2.8 线程池&emsp;4.2.9 Fork-Join 框架&emsp;4.2.10 Executor 框架&emsp;4.2.11 综述 4.3 并发开源库&emsp;4.3.1 Akka&emsp;4.3.2 RxJava 5 性能与测试&emsp;5.1 避免活跃性危险&emsp;5.2 性能测试&emsp;5.3 性能与可伸缩性&emsp;5.4 综述 6 总结6.1 并发思考&emsp;6.1.1 多线程的安全性问题&emsp;6.1.2 对象共享&emsp;6.1.3 从 Java 内存模型角度理解安全初始化&emsp;6.1.4 从任务到线程：Java 结构化并发应用程序&emsp;6.1.5 驾驭 Java 线程池：定制与扩展&emsp;6.1.6 尝试Java加锁新思路：原子变量和非阻塞同步算法 6.2 未来展望]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统]]></title>
    <url>%2F2019%2F07%2F01%2F1%2F2.3_distributed-system%2Fdistributed-system%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 简介 2 基本理论2.1 数据一致性&emsp;2.1.1 数据一致性理解&emsp;2.1.2 共识算法&emsp;2.1.3 分布式事务 2.2 高可用&emsp;2.2.1 高可用理解&emsp;2.2.2 负载均衡&emsp;2.2.3 限流&emsp;2.2.4 降级&emsp;2.2.5 补偿 2.3 伸缩性&emsp;2.3.1 有状态与无状态&emsp;2.3.2 高内聚低耦合&emsp;2.3.3 弹性架构&emsp;2.3.4 垂直与水平扩展 2.4 高性能&emsp;2.4.1 缓存&emsp;2.4.2 异步&emsp;2.4.3 阻塞与非阻塞 2.5 易测试&emsp;2.5.1 6个测试方法 2.6 易运维&emsp;2.6.1 监控&emsp;2.6.2 日志系统 3 分布式系统构建3.1 容器技术&emsp;3.1.1 容器原理&emsp;3.1.2 隔离与限制&emsp;3.1.3 镜像&emsp;3.1.4 重识 Docker&emsp;3.1.5 从容器到容器云 3.2 集群搭建3.3 容器网络3.4 调度与资源管理3.5 监控与日志]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F2_notes%2Fnotes%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;勿忘初心&emsp;&emsp;追求简约的设计&emsp;&emsp;成功与失败并无绝对]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6.1.6 尝试Java加锁新思路：原子变量和非阻塞同步算法]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent616%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.5 驾驭 Java 线程池：定制与扩展]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent615%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.4 从任务到线程：Java 结构化并发应用程序]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent614%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.3 从 Java 内存模型角度理解安全初始化]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent613%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.2 对象共享]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent612%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.1 多线程的安全性问题]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent611%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.4 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent54%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.3 性能与可伸缩性]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent53%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.2 性能测试]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent52%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1 避免活跃性危险]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent51%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3.2 RxJava]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent432%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3.1 Akka]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent431%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.11 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent4211%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.10 Executor 框架]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent4210%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.9 Fork-Join 框架]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent429%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.8 线程池]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent428%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.7 同步辅助工具]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent427%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.6 阻塞队列]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent426%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.5 非阻塞队列]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent425%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.4 并发集合]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent424%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.3 原子变量]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent423%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.2 锁机制]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent422%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.1 简介]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent421%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.4 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent414%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.3 线程通信]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent413%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.2 线程应用]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent412%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.1 线程简介]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent411%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.8 线程池模式（Worker Thread Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent338%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.7 单线程消息模式（Thread-Per-Message Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent337%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.6 读写锁模式（Read-Write Lock Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent336%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.5 生产消费模式（Producer-Consumer Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent335%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.4 回避模式（Balking Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent334%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.3 保护性暂挂模式（Guarded Suspension Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent333%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.2 不变模式（Immutable Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent332%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.1 单线程模式（Single Threaded Execution Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent331%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.8 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent328%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.7 其他特征]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent327%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.6 流控]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent326%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.5 消息]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent325%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.4 同步原语]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent324%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.3 死锁]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent323%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.2 临界段]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent322%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.1 同步]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent321%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.5 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent315%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.4 各种分解方式比较]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent314%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.3 数据流分解]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent313%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.2 数据分解]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent312%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.1 任务分解]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent311%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.8 面向高性能数据组织]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent258%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.7 cache 相关]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent257%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.6 存储问题]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent256%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.5 线程安全函数和库]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent255%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.4 非阻塞算法]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent254%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.3 锁竞争]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent253%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.2 数据竞争、死锁和活锁]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent252%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.1 线程过多]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent251%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.7 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent247%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.6 组合]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent246%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.5 不变性]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent245%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.4 线程封闭]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent244%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.3 可见性]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent243%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.2 锁机制]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent242%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.1 原子性]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent241%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.9 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent239%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.8 happens-before]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent238%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.7 final 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent237%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.6 锁 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent236%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.5 volatile 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent235%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.4 顺序一致性]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent234%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.3 重排序]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent233%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.2 基础]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent232%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.1 简介]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent231%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.5 综述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent225%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.4 原子操作的实现原理]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent224%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.3 锁以及锁升级]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent223%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.2 Java 对象头]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent222%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.1 并发底层实现原理]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent221%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.5 虚拟环境：虚拟机与虚拟平台]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent215%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.4 应用程序设计模型与多线程技术]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent214%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 线程创建后的相关行为]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent213%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2 线程的层次]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent212%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1 线程定义]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent211%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3 Java 中的锁与线程模型]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent13%2F</url>
    <content type="text"><![CDATA[概述 并发：同一时间应对(dealing with)多件事情的能力 并行：同一时间动手做(doing)多件事情的能力 并发程序的执行通常是不确定的，其结果依赖于事件时序．对于真正的并发程序，不确定性是其与生俱来且伴随始终的属性．而并行程序可能是确定的． 并行架构 位级并行：32位，64位 指令级并行：流水线，乱序，猜测执行 数据级并行: SIMD 任务级并行: 多处理器模型 锁与线程模型D1 线程和锁模型其实是对底层硬件运行过程的形式化，这既是这种模型的最大优点，也是这种模型的最大缺点． 线程和锁模型的三个危害： 竞态条件：代码行为取决于各操作的时序(常用同步来消除竞态条件) 内存可见性: 何时一个线程对内存的修改对另一个线程可见．(锁和volatile来保证可见性) 死锁: 多把锁加锁顺序不当导致各个线程都阻塞而不能继续执行的情况．(避免在持有锁的同时调用自己一无所知的方法,即外星方法．因为这就可能导致在加锁顺序一无所知的情况下使用两把锁而导致发生死锁) Java内存模型如何保证对象初始化是线程安全的?是否必须通过加锁才能在线程之间安全的公开对象? JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化. 新的 JMM 还寻求提供一种新的初始化安全性保证——只要对象是正确构造的（意即不会在构造函数完成之前发布对这个对象的引用，换句话说，不要让其他线程在其他地方能够看见一个构造期间的对象引用），然后所有线程都会看到在构造函数中设置的final字段的值，不管是否使用同步在线程之间传递这个引用。而且，所有可以通过正确构造的对象的final字段可及的变量，如用一个final字段引用的对象的final字段，也保证对其他线程是可见的。这意味着如果final字段包含，比如说对一个 LinkedList 的引用，除了引用的正确的值对于其他线程是可见的外，这个LinkedList在构造时的内容在不同步的情况下，对于其他线程也是可见的。 在讲了如上的这段之后，如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），你希望保证这个对象被其他线程正确的查看，你仍然需要使用同步才行。 “双重检查锁模式”（double-checked locking）以及为什么称之为反模式??? 关键在于：指令重排序导致在多线程情况下，其他线程可能访问到未初始化的对象。 解决方案有二：用volatile修饰instance对象；采用Initialization On Demand Holder idiom方案，即基于类的初始化方案（关键是JVM在初始化类的时候需要获取一把锁）。 选择方法：如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。 D2 ReentranLock 和 Atomic原子类 可以在线程持有锁的时候中断锁 可以设置线程获取锁的超时事件 按任意顺序来获取和释放锁 条件等待 atomic实现lock-free无锁操作． ReentrantLock创建时可以设置一个描述公平性的变量。什么是“公平”的锁？何时适合使用公平锁？使用非公平的锁会怎样？ 如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的；反之，则是非公平锁。 公平锁的性能不如非公平锁——公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配；另一方面，公平锁可以防止“饥饿”情况的产生，在以TPS为唯一指标的场景下，可以考虑使用公平锁。 什么是ReentrantReadWriteLock？它与ReentrantLock有什么区别？适用于什么场景？ ReentrantReadWriteLock的中文名称是读写锁，在多线程场景中，如果没有写线程在操作模板对象，读写锁允许多个读线程同时读。当对于某个数据结构的操作主要是读操作而只有少量的写操作时，就非常适合使用ReentrantReadWriteLock。 什么是“虚假唤醒”（spurious wakeup）？什么时候会发生虚假唤醒？为什么符合规范的代码不用担心虚假唤醒？（1）线程有可能在没有调用过notify()和notifyAll()的情况下醒来；（2）查看如下代码，doWait方法中发生了虚假唤醒——等待线程即使没有收到正确的信号，也能够执行后续的操作。 123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; （3）为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点： 123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 什么是AtomicIntegerFieldUpdater？它与AtomicInteger有什么区别？适用于什么场景？（1）AtomicIntegerFieldUpdater用于保证已经new出来的实例的原子性，AtomicInteger用于构造具备原子性的Integer实例。（2）使用第三方库的时候，如果需要给第三方库提供的对象增加原子性，则使用AtomicIntegerFieldUpdater。 D3总结 使用线程池而不是直接创建线程 使用CopyOnWriteArrayList 避免使用外星方法导致的死锁问题 使用ArrayBlockingQueue来使得生产者和消费者高效协作 ConcurrentHashMap提供了更好的并发访问 问题 Fork/Join和线程池的区别，以及分别适用的场景 ForkJoinPool 相比于ThreadPoolExecutor，还有一个非常重要的特点（优点）在于，ForkJoinPool具有 Work-Stealing （工作窃取）的能力。所谓 Work-Stealing，在 ForkJoinPool 中的实现为：线程池中每个线程都有一个互不影响的任务队列（双端队列），线程每次都从自己的任务队列的队头中取出一个任务来运行；如果某个线程对应的队列已空并且处于空闲状态，而其他线程的队列中还有任务需要处理但是该线程处于工作状态，那么空闲的线程可以从其他线程的队列的队尾取一个任务来帮忙运行 —— 感觉就像是空闲的线程去偷人家的任务来运行一样，所以叫 “工作窃取”。 Work-Stealing 的适用场景是不同的任务的耗时相差比较大，即某些任务需要运行较长时间，而某些任务会很快的运行完成，这种情况下用 Work-Stealing 很合适；但是如果任务的耗时很平均，则此时 Work-Stealing 并不适合，因为窃取任务时也是需要抢占锁的，这会造成额外的时间消耗，而且每个线程维护双端队列也会造成更大的内存消耗。所以ForkJoinPool并不是ThreadPoolExecutor的替代品，而是作为对 ThreadPoolExecutor 的补充。 ThreadPoolExecutor 只能执行 Runnable 和 Callable 任务，而 ForkJoinPool 不仅可以执行 Runnable 和 Callable 任务，还可以执行 Fork/Join 型任务 ForkJoinTask 从而满足并行地实现分治算法的需要； ThreadPoolExecutor 中任务的执行顺序是按照其在共享队列中的顺序来执行的，所以后面的任务需要等待前面任务执行完毕后才能执行，而 ForkJoinPool 每个线程有自己的任务队列，并在此基础上实现了 Work-Stealing 的功能，使得在某些情况下 ForkJoinPool 能更大程度的提高并发效率。 CountDownLatch 和 CyclicBarrier 的区别?? CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. 从javadoc的描述可以得出： CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行； CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。 线程和锁模型优缺点优点 线程和锁模型更接近于本质– 近似于对硬件工作方式的形式化，正确使用时候，效率很高．而且也能解决从小到大不同粒度的问题． 大多数语言支持． 缺点 没有为并行提供直接的支持，不支持分布式内存 难于测试，很多时候我们并不知道自己在坑中，bug难以重现． 可维护性较差 基本规则 访问共享变量需要同步 获取多把锁时候需要按照全局固定的顺序 持有锁的时候避免调用外星方法]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 并行编程模型]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent12%2F</url>
    <content type="text"><![CDATA[1 并行编程模型分类在计算领域，并行编程模型是并行计算机体系架构的一种抽象，它便于编程人员在程序中编写算法及其组合。一个编程模型的价值可以通过其通用性（generality）来判断，如不同体系架构的一系列不同的问题能否在该模型中很好地表示以及其性能如何，编译后的程序执行效率有多高等。并行编程模型的实现有两种方式，作为已有的语言的一种扩展，通过库的形式来调用，或者作为一种全新的语言。 围绕一个实际的编程模型的共识是重要的，因为它会导致构建出支持该模型的不同的并行计算机，从而提高软件的兼容性。在这种意义上说，编程模型是硬件和软件之间的桥梁。 并行编程模型宽泛的可以分为三类： 进程通信（process interaction） 问题分解（problem decomposition） 隐式并行（parallel Processing） 下面我们简要介绍这三类模型有哪些形式。 1.1 进程通信进程通信涉及并行进程互相通信的机制。最常用的通信形式： 共享内存（shared memory） 消息传递（message passing） 分布式内存（distributed shared memory） 1) 共享内存共享内存是在进程间传递数据的高效方式。在共享内存模型中，并行进程共享它们可以异步读与写的全局地址空间。异步并发访问可能导致竞争条件，和用来避免它们的机制如：锁、信号量和监视器。常规的多核处理器直接支持共享内存，很多并行编程语言和库在设计上利用了它，比如采用Fork-join模型的：Cilk、OpenMP和线程建造块。 2) 消息传递在消息传递模型中，并行进程通过消息传递相互交换数据。这种通信可以时异步的，就是说消息可以在接收者准备好之前发出，或时同步的，就是说消息发出前接收者必须准备好。通信顺序进程（CSP）形式化了使用同步通信通道来连接进程的消息传递，并引出了重要的语言如：Occam、Limbo和Go。与之相对，演员模型使用异步消息传递，并被采用于如下语言的设计中：D、Scala和SALSA。 3) 分布式内存分布式内存指称一类多处理器计算机系统，其中每个处理器都有自己私有的内存，计算任务只能在本地数据上运算，如果需要远程数据，计算任务必须与一个或多个远程处理器通信。在分布式内存系统编程中的关键要点是如何把数据分布到各个内存上；依赖于所解决的问题，数据可以静态分布，也可以在节点间移动；数据可以在需要时移动，也可以事先推入新的节点。 MPI规定了用于分布式内存系统的通信协议，支持点到点通信和集体通信（collective communication）二者。MPI还是消息传递API，带有对其特征在任何实现中必须如何表现的协议和语义规定。MPI的目标是高性能、可伸缩性和可移植性，当前仍是高性能计算领域中统治性的模型。此外还有支持单边通信（one-sided communication）的分区全局地址空间模型。 1.2 问题分解并行程序是由同时运行的进程组成。问题分解涉及所有进程如何被组织起来的方式。问题分解包括二种并行模型： 任务并行模型（task parallelism） 数据并行模型（data parallelism） 1) 任务并行任务并行模型关注进程或线程的执行。这些进程通常表现出独特性，并强调对通信的需求。任务并行是表达消息传递通信的自然方式。任务并行通常对应MPMD编程模型，与SPMD的区别在于适合解决的问题而非执行模型。 2) 数据并行数据并行模型关注进行运算所在的数据集，典型的是正规结构的数组。一组任务将在这些数据上运算，但是单独的处于在不相交的分区中。数据并行通常对应SPMD编程模型，相应执行模型对应费林分类法中的SIMD（例如AVX扩展）或MIMD（例如Xeon Phi），还有GPGPU采用的SIMT（例如NVIDIA Tesla）。 1.3 隐式并行在隐式通信中，进程通信对程序员来说是不可见的，主要由编译器、运行时或硬件负责实现。进程通信是由编译器或者运行时来处理和实现。并发被预置在高级操作子中的领域特定语言（domain-specific language）和函数式编程语言是隐式并行的典型例子，因为无副作用（side-effect）允许非依赖的函数可以并发执行。但是这种并行模式是很难管理的。函数式语言如Concurrent Haskell和Concurrent ML提供了显示管理并行化的功能。 2 并行编程模型的例子这里列出的编程模型是可称为桥接模型的计算机的抽象模型，它提供了在一个机器的物理实现和编程者可获得的这个机器的抽象概念之间的桥梁；换句话说，它意图在硬件和软件工程师之间提供共同的理解层面。成功的编程模型可以在现实中有效的实现并被编程者有效的作为目标；特别是应当有可能用典型的高级语言编译器生成良好的代码。从编程者的角度来看，这种并行编程模型典型的位于OpenMP、OpenACC等之下而在Pthreads、IPC、MPI等之上。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 概述]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.2_concurrent%2Fconcurrent11%2F</url>
    <content type="text"><![CDATA[并发计算，简单来说，就是将一个计算任务，分割成几个小的部分，让它们同时被计算，之后再汇整计算结果，以完成任务。它跟并行计算（Parallel computing）与分布式计算，有重叠之处，在概念上不同，但常会让人混淆。 并发计算是一种程序运算的特性，可以被视为是并行运算的进一步抽象，它包涵了时间片这种可以被用来实现虚拟并行运算（Pseudoparallelism）的技术，因此在实际的物理运作中，计算过程可能是并行，或非并行的。 并行计算是指，当并发计算的程序，在机器平台上同时被运行的状况，因此，并行计算是一种机器运算的形式之一。分布式计算（Distributed computing）则是并行计算的一个特例，它采用计算机网络来进行同步。 实现并发程序有许多方式，依编程语言与操作系统的支持，可以用进程，或是线程来实现。它可以运行在单一处理器上，将不同的运行步骤分散在不同时间片中运行，以非并行方式循序运算；它也可以用并行计算来实现，将每个行程指定给处理器组中的某个处理器，以单片机多处理器平台，或是透过网络链接的分散平台来实做。 依照硬件与操作系统的支持，并发计算可以在同一个行程中完成，在同一个行程中以多线程来完成，以多个行程来达成，甚至可以分成数个程序来运行。可以用单处理器的循序计算来实现，也可以采并行计算或分布式计算方式实做。 但以并行方式来运作并发程序，并不必然会增进运行效率。因为运行结果可能会因为平台特性而改变，也增加它在设计上的难度。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL百万级数据分页查询及优化]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F1_technology%2Ftechnology3%2F</url>
    <content type="text"><![CDATA[&emsp;方法1: 直接使用数据库提供的SQL语句语句样式: MySQL中,可用如下方法: SELECT FROM 表名称 LIMIT M,N适应场景: 适用于数据量较少的情况(元组百/千级)原因/缺点: 全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3). Limit限制的是从结果集的M位置处取出N条输出,其余抛弃.&emsp;&emsp;方法2: 建立主键或唯一索引, 利用索引(假设每页10条)语句样式: MySQL中,可用如下方法: SELECT FROM表名称: WHERE id_pk &gt; (pageNum10) LIMIT M适应场景: 适用于数据量多的情况(元组数上万)原因: 索引扫描,速度会很快. 有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法3&emsp;&emsp;方法3: 基于索引再排序语句样式: MySQL中,可用如下方法: SELECT FROM表名称 WHERE id_pk &gt; (pageNum10) ORDER BY id_pk ASC LIMIT M适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1)原因: 索引扫描,速度会很快. 但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待…).&emsp;&emsp;方法4: 基于索引使用prepare第一个问号表示pageNum，第二个？表示每页元组数语句样式: MySQL中,可用如下方法: PREPARE stmt_name FROM SELECT FROM 表名称 WHERE id_pk &gt; (？ ？) ORDER BY id_pk ASC LIMIT M适应场景: 大数据量原因: 索引扫描,速度会很快. prepare语句又比一般的查询语句快一点。&emsp;&emsp;方法5: 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描比如: 读第1000到1019行元组(pk是主键/唯一键).SELECT FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20&emsp;&emsp;方法6: 利用”子查询/连接+索引”快速定位元组的位置,然后再读取元组.比如(id是主键/唯一键,蓝色字体时变量)利用子查询示例:SELECT FROM your_table WHERE id &lt;=(SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize ORDER BY id descLIMIT $pagesize 利用连接示例: SELECT FROM your_table AS t1JOIN (SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize AS t2WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize; mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。 测试实验 直接用limit start, count分页语句， 也是我程序中用的方法： select * from product limit start, count 当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。 如下： select from product limit 10, 20 0.016秒select from product limit 100, 20 0.016秒select from product limit 1000, 20 0.047秒select from product limit 10000, 20 0.094秒 我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一般左右） select * from product limit 400000, 20 3.229秒 再看我们取最后一页记录的时间 select * from product limit 866613, 20 37.44秒 像这种分页最大的页码页显然这种时间是无法忍受的。 从中我们也能总结出两件事情： limit语句的查询时间与起始记录的位置成正比 mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。 对limit分页问题的性能优化方法 利用表的覆盖索引来加速分页查询我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。 因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。 在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何。 这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下： select id from product limit 866613, 20 0.2秒 相对于查询了所有列的37.44秒，提升了大概100多倍的速度 那么如果我们也要查询所有列，有两种方法，一种是id&gt;=的形式，另一种就是利用join，看下实际情况： SELECT * FROM product WHERE ID &gt; =(select id from product limit 866613, 1) limit 20 查询时间为0.2秒！ 另一种写法 SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id 查询时间也很短！ 复合索引优化方法 MySql 性能到底能有多高？MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。 用事实说话，看例子： 数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用硬1.6G。 OK ,看下面这条sql语句： select id,title from collect limit 1000,10; 很快；基本上0.01秒就OK，再看下面的 select id,title from collect limit 90000,10; 从9万条开始分页，结果？ 8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句: select id from collect order by id limit 90000,10; 很快，0.04秒就OK。 为什么？因为用了id主键做索引当然快。网上的改法是： select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10; 这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句 select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！ 到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接 select id from collect where vtype=1 limit 1000,10; 是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。 从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下： 建一个索引表： t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。 是否可行呢？实验下就知道了。 10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用 select id from t where vtype=1 order by id limit 90000,10; 很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？ 错！因为我们的limit还是9万，所以快。给个大的，90万开始 select id from t where vtype=1 order by id limit 900000,10; 看看结果，时间是1-2秒！why ? 分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！ 难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？ 答案是： NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！ 好了，我们的测试又回到 collect表，开始测试结论是： 30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！ 答案就是：复合索引！ 有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？ 开始的 select id from collect order by id limit 90000,10; 这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。 然后测试 select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！ 再测试: select id ,title from collect where vtype=1 limit 90000,10; 非常遗憾，8-9秒，没走search索引！ 再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。 综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！ 完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 搭建 socks 服务器（翻墙）]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F1_technology%2Ftechnology2%2F</url>
    <content type="text"><![CDATA[下面笔者将用SS5在亚马逊云服务器上的Linux搭建一台Socks5 Proxy Server（用海外阿里云 也可以）具体过程如下： 一，服务端1、首先，编译安装SS5需要先安装一些依赖组件1yum -y install gcc gcc-c++ automake make pam-devel openldap-devel cyrus-sasl-devel openssl-devel 2、下载SS5最新版本的源代码官网 http://ss5.sourceforge.net/1wget https://nchc.dl.sourceforge.net/project/ss5/ss5/3.8.9-8/ss5-3.8.9-8.tar.gz 3、解压后开始编译安装：12345tar zxvf ./ss5-3.8.9-8.tar.gzcd ss5-3.8.9./configuremakemake install 4、让 SS5 随系统一起启动（建议手动启动）123chmod +x /etc/init.d/ss5chkconfig --add ss5chkconfig --level 345 ss5 on 5、设置 ss5 账号密码在ss5.conf中找到auth和permit两行，按照下面的格式进行修改12vi /etc/opt/ss5/ss5.conf（这是 未设置 账号密码）vi /etc/opt/ss5/ss5.passwd（需要 设置 账号密码） 6、设置 ss5 端口默认使用1080端口，并允许任何人使用，如果要修改默认端口，请修改1vi /etc/sysconfig/ss5 在/etc/sysconfig/ss5这个文件中，添加下面这一行命令，-b后面的参数代表监听的ip地址和端口号12# Add startup option hereSS5_OPTS=&quot; -u root -b 0.0.0.0:10808&quot; 7、ss5 操作123service ss5 start（启动ss5）service ss5 status（查看ss5状态）service ss5 stop（停止ss5） 8、检查服务是否启动成功1netstat -an | grep 10808 二，客户端1、Mac 端 2、windows 端需要自己下载 socks 代理]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔——勿忘初心]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F2_notes%2Fnotes3%2F</url>
    <content type="text"><![CDATA[&emsp;我一直很想表达一种时代精神：努力生活，努力前进，朝气蓬勃，年轻的活力。&emsp;爱自己所做的事业，也相信一定会继续进步，就像过去的其他人一样。大家都有一个从不成熟到成熟的过程，当你工作十年，你的技巧会更丰富。&emsp;但最重要的是不要忘记了你的初心，就是那份最纯粹的快乐。&emsp;&emsp; ——水门写于杭州（2020-01-29）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的那些锁事（转载）]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F1_technology%2Ftechnology1%2F</url>
    <content type="text"><![CDATA[前言Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录： 1. 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 根据从上面的概念描述我们可以发现： 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例： 12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。 CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 CAS算法涉及到三个操作数： 需要读写的内存值 V。进行比较的值 A。要写入的新值 B。当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义： 根据定义我们可以看出各属性的作用： unsafe： 获取并操作内存的数据。valueOffset： 存储value在AtomicInteger中的偏移量。value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码： ------------------------- JDK 8 -------------------------1234567891011121314151617181920212223// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 2. 自旋锁 VS 适应性自旋锁在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。 在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。 首先为什么Synchronized能实现线程同步？ 在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。 Java对象头synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点： 无锁无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁锁升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 整体的锁状态升级流程如下： 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 4. 公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： 接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。 根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。 下面我们来看一下公平锁与非公平锁的加锁方法的源码: 通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 5. 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 6. 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 下图为ReentrantReadWriteLock的部分源码： 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 了解了概念之后我们再来看代码，先看写锁的加锁源码： 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 结语本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。 其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单及资料]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F3_book%2F</url>
    <content type="text"><![CDATA[一，计算机科学1，数学 同济大学高等数学上册 同济大学高等数学下册 程序员的数学 1 程序员的数学 2 概率统计 程序员的数学 3 线性代数 史济怀-数学分析教程上 史济怀-数学分析教程下 2，算法 计算机程序设计艺术(中文版)第一卷：基本算法 计算机程序设计艺术(中文版)第二卷：半数值算法 计算机程序设计艺术(中文版)第三卷：排序与查找 算法设计与分析 3，计算机系统 深入理解计算机系统 多处理器编程的艺术 多核程序设计艺术 分布式理论 4，计算机应用 复杂性思考 简约之美_软件设计之道 二，计算机工程与技术1，代码 设计模式 代码大全 代码整洁之道 架构整洁之道 设计模式解析 七周七并发 图解性能优化 系统架构 重构 2，编程 Java 编程思想 Java 并发编程的艺术 Java 多线程编程核心技术 Effective Java 多线程编程实战 NIO 与 Socket 编程技术指南 spring 源码分析 Java 虚拟机规范 揭秘Java虚拟机 深入理解 JVM 虚拟机 领域驱动设计 3，服务器 Linux 命令 4，中间件 Mysql 技术内幕 InnoDB 存储引擎 数据库事务处理的艺术 高性能 mysql Redis 原理分析 Mq 原理分析 从 Paxos 到 ZooKeeper 三，论文1，Java JSR133 JSR107 Specification The java.util.concurrent Synchronizer Framework A Java Fork/Join Framework 四，其他 java 架构知识库整理 浅谈人工智能 阿里巴巴Java开发手册终极版v1.3.0]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔——追求简约的设计]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F2_notes%2Fnotes2%2F</url>
    <content type="text"><![CDATA[&emsp;软件是必然变化的，变化是常态；有变化就需要维护，随着时间的推移，维护成本必然会远远超过开发成本，占据整个软件成本的⼤半，因此，在软件开发中，降低维护成本是重中之重的事情，而维护成本正⽐于系统的复杂程度，因此想要降低维护成本，系统就应当追求简单而清晰的设计。&emsp;而简洁，是我们所追求的。代码越简洁，未来做改动的难度就越低，测试也会越准确，对于软件性能也就会越有把握。但简洁并不等于少，⽽是没有多余的东⻄，同时，简洁也是相对的，因为变化从来都是不可能避免的，⼀味杜绝是错误思路，唯⼀可⾏的⽅式是将变化的范围限定在⼀个尽可能⼩的范围内，换句话说就是好的设计能尽可能适应外部尽可能多的变化，同时软件⾃身的变化尽可能的少。&emsp;说到设计，其实程序员也是设计师，与其他⾏业⼀样，软件设计本身也是有科学的，尽管，科学并不等于全知全能。但依然是有章可循的，它们可以被认识，可以被理解。永恒不变的，也是最基本的事实，⽽且确实可⾏。只是很可惜，当今的软件开发⾮常复杂，整个软件⾏业的整体状态是⽅法众多，⽽且存在着彼此的⽭盾却各有道理的观点，这就说明整个软件管理的基本规律尚未被认识，也就是说真正的科学是缺失的。所以，现实中，技术决策的好坏，更多的是来源于主要决策者的智⼒、胆识与经验。&emsp;&emsp; ——水门写于杭州（2017-09-03）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>软件编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开发手册解析]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F5_standard%2Fstandard1%2F</url>
    <content type="text"><![CDATA[代码规约命名规约1234567891.1.1 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束1.1.2 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式1.1.3 / 1.1.4 类名使用UpperCamelCase风格，必须遵从驼峰形式（某些情况诸如领域模型相关的命名除外）；方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式1.1.5 常量命名全部大写，单词间用下划线隔开1.1.9 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词 上述规则，主要是规定了你书写Java的时候，哪些字符可以用，什么时候用大写，什么时候用小写。应该说，绝大多数写Java的都遵循着上述的规范，就像笔者说的：尼玛这都不懂，乘早改行别写Java了。 笔者在实际编程过程中，对类名的风格，可能更激进一些，根据阿里的规范： 1类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO等 实际上还是有可能会存在着诸如：UserVO，UserDTO，UserDAO这样的命名。对不起，在笔者的团队中，这样的命名也会被禁止，这里分为2种情况：1禁止使用 VO / BO / DTO / VO 等进行领域模型的命名 有读者要问，那么如果万一项目中要使用DTO或者VO咋办？笔者的观点如下： 第一，项目中避免使用DTO或者VO，DTO是一个早在2004年就被讨论并认定为一个反模式的东西； 第二，谁规定领域模型就一定要用DTO或者VO做结尾？还原领域模型的本来意义才是命名的核心，一个User在实际业务系统中可能是一个Admin或者Supervisor，那就直接用Admin来命名，而不是把User转化成UserVO，UserVO啥都不是，是初级程序员造出来的一个怪胎。 1所有的DAO使用正常的驼峰法进行命名，例如：UserDao 对上面这条，或许有很多DAO大写党要发飙了。其实笔者就想反问这些人一句：你咋不把UserService写成UserSERVICE呢？ 命名原则1231.1.5 力求语义表达完整清楚，不要嫌名字长1.1.10 杜绝完全不规范的缩写，避免望文不知义 这两条说的是命名的基本原则，总的来说其实表达了一个意思：你他妈的别给我用缩写！ 其实有很多程序员会非常神奇的患上「缩写综合症」。比如非常典型的就是：UserMgmt，这他妈是什么鬼？多敲几个字母会死么？ 类的命名12345678910111.1.6 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾1.1.13 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别1.1.13 如果是形容能力的接口名称，取对应的形容词做接口名1.1.14 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开1.1.11 如果使用到了设计模式，建议在类名中体现出具体模式1.1.9 包名统一使用单数形式；类名如果有复数含义，类名可以使用复数形式 上述规则，主要在讲述具体命名一个类的时候的一个「用词规范」。这些用词规范绝大多数实际上也是一种约定俗成，比如Abstract前缀，Exception后缀等等。 对于接口的命名，笔者最为不能忍受的一种命名，就是将所有的接口以大写字母I开头，诸如：IUserService。真是一种坑爹到极致的命名：第一，IUserService纠结是一个啥玩意儿？好好的UserService，加上一个大写字母I，直接失去了阅读时的语义性；第二，谁他妈知道你这东西到底是大写字母I还是数字1啊？ 有关枚举类名是否加上Enum后缀，笔者对此有所保留。在笔者的团队中，是不使用Enum作为后缀的，但对此并不反感。至于枚举成员名称，不用大写字母并下划线隔开的，基本属于缺心眼行为。Enum的设计初衷就是对常量的规整和扩展，所以命名规范继承自常量是比较合理的一种选择。 在命名中体现设计模式，相信这一点很多程序员都能遵守。因为在笔者看来，能在代码中熟练使用设计模式的同学，通常也不会是一个对自己毫无要求的烂货。这条命名规范在Spring以及很多优秀的开源项目中都有很深刻的体现。 类名是否可以使用复数形式，相信主要的分歧来自于工具类。笔者的规定是： 1提供一系列静态方法的工具类，一概使用Utils作为后缀命名 这条规范的依据，主要来自于笔者发现commons和spring这两个比较优秀的开源框架中提供的工具类通常都带s结尾。 常量规约1234567891.2.1 不允许出现任何魔法值（即未经定义的常量）直接出现在代码中1.2.3 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护1.2.4 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量1.2.5 如果变量值仅在一个范围内变化用Enum类。如果还带有名称之外的延伸属性，必须使用Enum类1.1.12 尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量 常量规约的核心有两点：第一，别使用常量；第二，让常量可控。 常量的存在按照笔者个人的理解是向下兼容的选择（因为JDK1.5之后才出现枚举）外加用起来足够爽（想象一下静态调用时引用的便捷性，甚至基本类型可以直接参与业务逻辑的计算）。 所以在上述规则中，我们可以看到常量进化到枚举的趋势，也能看到由于用起来足够爽带来的常量管理需求：要求分组（1.2.3）以及要求放在合适的位置（1.2.4）。 有关分组，笔者有不同意见：常量分组未必要分散到不同的类，在一个常量类中定义静态类也是一种分组方式，有时候这样的分组方式可能管理起来更有效。 至于接口中只能定义常量不能定义变量，基本就属于幼儿园规则了。 语法糖123456789101112131415161718191.2.2 long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解1.1.12 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释1.4.2 所有的覆写方法，必须加@Override注解1.4.3 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）1.4.4 对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么1.4.5 不能使用过时的类或方法1.4.10 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败1.4.17 循环体内，字符串的联接方式，使用StringBuilder的append1.4.18 final可提高程序响应效率1.4.19 慎用Object的clone方法来拷贝对象 有关语法糖的总结其实比较牵强，因为绝大多数的规则看上去都比较小儿科，比如像覆写方法的@Override注解，@Deprecated注解，可变参数的问题等等基本上都在IDE层面解决了。 当一个项目在IDE中产生了一些由于使用过时方法之类的事儿导致的warning时，有洁癖的程序员应该主动修复这个warning。这也是是一个程序员的基本素养问题。 最后的三条，笔者认为有点鸡肋，对于初级程序员，大多还到不了考虑final和clone的层次；而中高级程序员，这几条规则对他们而言并无问题。 基本类型1234567891.2.2 long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解1.4.7 所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较1.4.8 所有的POJO类属性必须使用包装数据类型1.4.8 RPC方法的返回值和参数必须使用包装数据类型1.4.8 所有的局部变量【推荐】使用基本数据类型 有关基本类型的声明（1.2.2）和比较（1.4.7），这两条规则比较直观，不再叙述。 而有关基本类型和包装类型的使用，这东西一直是吵架的核心。用还是不用？这是个问题！很显然，阿里同学的观点是：为了提高程序的容错性和扩展性，尽可能使用包装类型。 从阿里同学举的例子来说，也是有一定说服力的： 1234数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息 不过笔者认为，如果程序员对程序能够驾驭得比较好，基本类型也是一种很好的选择。因为基本类型有一些比较好用的特性：比如说默认值。笔者在这里也举个例子进行说明： 通常我们都会用is_disabled字段在数据库中表示某一个表的记录是否被逻辑删除，而这个字段，在Java代码中被映射成什么类型呢？ Boolean？如果被映射成包装类型，那么数据库里面的这个字段就可以为null，有些读者会说，这并没有什么问题啊。可是，数据库is_disabled字段如果为null，代表什么逻辑含义呢？这条记录究竟是有效还是无效？ 如果这个字段不能为null，那么将其映射成基本类型是一个皆大欢喜的事情：既保证了数据库数据的完整性，我们在初始化的时候还可以忽略这个字段，因为boolean天生的默认值就是false 所以，笔者对于包装类还是基本类型的结论是： 1一切跟着业务的实际情况而定，基本类型也有其生存空间 方法命名12345671.1.15 Service/DAO层方法命名规约 - 获取单个对象的方法用get做前缀 - 获取多个对象的方法用list做前缀 - 获取统计值的方法用count做前缀 - 插入的方法用save（推荐）或insert做前缀 - 删除的方法用remove（推荐）或delete做前缀 - 修改的方法用update做前缀 有关方法的命名，笔者想多说几句不同意见。对于上述的规则，笔者认为适合在DAO这个层次进行实践，而不能应用于Service层。 使用Hibernate作为持久层框架的读者，对Hibernate的API应该比较熟悉，而上面的命名规范，和Hibernate对外暴露的API名称是很接近的。我们知道，通常到了DAO这个层次，数据库操作相对来说是一个原子操作，所以增删改查的语义是最适合做方法命名的。这也就是笔者认为这套规则在DAO层能够被实践得很好的一个原因。 当然，上述规则中有一个例外：1获取单个对象用load做前缀，避免使用get 原因很简单，get可能是getter方法的前缀，作为一个偏执狂，老子不冒风险。 话题回到Service的命名上来，为什么笔者不认同使用相同的命名规范作用于Service层呢？因为Service层通常是对外暴露的接口，具有一定的业务意义，也就是说Service层通常也不会是简单的增删改查，而是若干原子操作的集合。 举两个很简单的例子：发短信。发短信这个业务中可能包含了本地配置的读取、本地数据库的读写，远程服务的调用。我们可以看到这是一连串数据库操作甚至是异构系统调用的集合实现，能用简单的增删改查来命名吗？所以，笔者的观点很简单：1Service层接口方法的命名，应还原业务的本来面目，采用动词或者动宾结构来进行方法的命名 举例来说：resetPassword / login / sendMessage 都是比较合理的命名方式。 方法和属性12345678910111.4.9 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值1.4.11 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中1.4.14 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读1.4.15 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法1.4.16 setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter方法中，尽量不要增加业务逻辑1.4.20 类成员与方法访问控制从严 这几条规约理解起来不难，执行起来也不难。要探究背后的原因，可能就需要花点功夫。 比如，构造方法和setter/getter方法禁止加入业务逻辑，主要是这些方法有很大概率被程序框架的反射机制调用。一旦其中含有业务逻辑，那么调试和定位就会变成灾难。 不过对于getter方法，通常要网开一面。因为在实际情况中，我们往往会在一个POJO中加入额外的getter方法用于序列化或者内部逻辑的使用。在这种情况下，避免和其他getter方法产生分歧是需要注意的地方。 至于说到类内的方法定义顺序，笔者基本同意上述规则，但在实际执行中可能更加严格：getter和setter方法的顺序也有严格讲究，必须是先getter方法，后setter方法，而不是让它们成对出现。 有关类成员和方法的访问控制，阿里的同学洋洋洒洒说了好几条，语法层面偏多，在这里就不再详细展开。 格式规约格式规约是代码规范中争议最大的，由于条目众多，在这里就不逐一解读，挑选几条大致说一下。12345671.3.5 缩进采用4个空格，禁止使用tab字符1.3 6. 单行字符数限不超过 120 个1.3.8 IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用windows格式1.3.10 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行 绝大多数情况下，空格党和Tab党的较量是空格党完胜。笔者也不记得是多少年前被一位前辈教育说禁止使用Tab，就保持了良好的习惯至今。对于缩进，个人比较赞同4个空格，但HTML等页面上使用4个空格的话，一些复杂页面的缩进就会比较恐怖，此时可以降级为2个空格。 对于单行字符数的限制不超过120个这条规则，笔者完全不能认同。这里面牵涉到的情况比较多，不能一棒子打死了。有些逻辑有大量的分支和循环的嵌套，如果遵循4个空格的缩进原则，碰到方法名称还比较长的状况，就要折行，这给代码阅读带来极大的困扰；另外有一种情况，就是需要额外进行比较长的注释编写，不能写在一行里的感觉真是比较糟糕，因为还得考虑断句才不影响阅读。另外，笔者有一个习惯是在条件语句边上加一句注释，这样就有很大概率会超出120字： 有人会问，条件语句边上加注释是什么鬼？从上面的代码上可以看到，条件语句上面的一行注释实际上在解释整个代码片段，而条件语句边上的注释说明的是条件语句本身！当然如果读者有更好的写注释的位置，请及时给笔者留言。 文件的UTF-8和Unix格式没什么好说的，IDE支持的也很好。但这一点对初级程序员尤为重要，我已经不知道多少次就这个问题惩罚过实习生了。 有关语句组空行，是笔者极力推荐的一个做法。这不仅仅是为了空行而空行，这里的空行本身就是一种编程思路的整理。而笔者还有一个习惯就是对比较复杂的逻辑，都在语句组的前面加上注释，注释也用编号编排，这样回头debug时也会极大提升效率。 集合类型阿里规范中的集合类型这个章节，感觉写得比较鸡肋。绝大多数的规范似乎都是针对初级程序员的。笔者看了半天也没总结出一条值得额外解读的，所以权当复习一遍基础知识就好。 并发处理12345671.6.1 获取单例对象需要保证线程安全，其中的方法也要保证线程安全1.6.2 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯1.6.3 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程1.6.4 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor去创建 上面这4条规则主要是针对线程的创建和使用。由于Spring的存在，其实上述情况不太可能发生。 123451.6.5 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁1.6.7 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁1.6.8 并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据 上面这3条规则主要是针对锁。不过这几条规则看上去更像是3道面试题的答案。这3道面试题分别是：12345使用锁同步，有什么需要注意的地方？什么是死锁？举例说明什么情况会发生死锁？什么是乐观锁？什么是悲观锁？分别用在什么场景？ 相信能解答上述面试题的同学，应该对上面的原则了然于心。 12345678910111.6.9 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题1.6.10 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至countDown方法，直到超时才返回结果回溯1.6.13 volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题1.6.14 HashMap在容量不够进行resize时由于高并发可能出现死链1.6.15 ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 上面这些规则基本上属于知识贴范畴，可以一带而过，有些可能不太会实际碰到。像定时任务，可能使用Spring的封装更多一些，而Spring默认就是使用ScheduledExecutorService的。 而CountDownLatch的异常捕获，也是一个老生常谈的问题了，属于多线程编程的基本功。 最后的三条对于写应用的同学接触不多，但写底层的同学应该会很熟悉。 代码风格121.7.1 在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有 这条主要是期待程序员人为把握好代码的执行逻辑。对于switch语句，如果没有终止语句，会依次执行每一个case块。实际上，笔者认为switch语句是一个比较差的语法糖，通常情况下都可以用更加优雅的方式来写，包括并不限于使用设计模式。所以在笔者的团队中是禁止使用switch语句的。11.7 2 在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements; 这一条比较有意思，因为这种一行式的代码风格，在javascript里面经常会看到，所以很多全栈工程师也会把它引入到Java中来。笔者对此并不反感，但确实在可读性上不那么友好。 123456781.7.3 推荐尽量少用else， if-else的方式可以改写成：if(condition)&#123;...return obj;&#125;// 接着写else的业务逻辑代码;1.7.3 如果非得使用if()...else if()...else...方式表达逻辑，【强制】请勿超过3层，超过请使用状态设计模式 上面这点笔者比较认同，因为else不仅会带来大段的代码缩进的困扰，同时也会降低代码的可读性。不过对于那些坚持必须在代码的最后一行统一return的同学，上面的写法可能就不太容易接受了。实际上，上述代码结构比较常见于Spring的源码中，倒不是尽早return，而是else的逻辑块可能直接throw异常出去了。 123451.7.4 除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);if (existed) &#123;...&#125; 有关这一条，补充说明一下：将复杂的逻辑判断结果赋值给一个有意义的布尔变量名，除了提高可读性之外，实际上能够极大方便调试。但笔者认为单单只是抽取部分代码，并不能提高可读性，而是应该将复杂的逻辑判断进一步封装为一个方法： 上面的代码片段中，左边是阿里风格，右边是陆老师的风格，大家可以比较一下，哪个更好？哪个更符合面向对象的思维呢？11.7.5 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作 这一条值得说一下，因为有些代码会走得比较深，写着写着就忘了它处于循环体的内部了。所以保持一个谨慎的心态比较重要。 1234567891011121.7.7 方法中需要进行参数校验的场景：1） 调用频次低的方法。 2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3） 需要极高稳定性和可用性的方法。 4） 对外提供的开放接口，不管是RPC/API/HTTP接口。5） 敏感权限入口。1.7.8 方法中不需要参数校验的场景： 1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数 这两条说的是参数校验，说的比较在理，也比较全面。比起很多公司的奇葩规定来说，要人性化得多。笔者认为需要补充的是：参数的校验主要还需要从格式和业务两个层面进行考量。业务层面的校验往往要比单纯的格式校验更为复杂，所以在写代码时可以建立一定层次的假设，当然这可能也会引入团队沟通的问题，需要根据实际情况权衡。 有关阿里代码风格方面的解读，受限于阿里自身提出的规约比较少。对此，笔者是稍有失望的。因为代码风格规约是最能够体现一个团队对于代码整洁程度的一个衡量标准。所以笔者忍不住在这里多加了几条笔者团队的共识，供读者参考：1在任何情况下，代码量越少越容易维护 基于上面的原则，笔者的团队会鼓励使用三目表达式对简要的if/else进行重构 当然，像下列左侧的代码，也会重构成右侧的： 一个复杂的Service层逻辑，不应超过30行，否则需要进行逻辑规整和抽象 在业务逻辑中尽可能不要使用setter方法，而是使用构造函数或者封装成一个有逻辑意义的方法，提高代码的可读性什么？连setter方法都不让用？这是什么SB一样的规约啊！事实上，笔者团队确实是这么做的，我们来看一下代码： 在上面的代码中，左侧代码中的setter方法调用，会被封装到ShuttleOrder对象中的cancel方法中去。在实际的service代码中，只会出现下半部分的一行代码。 这样做的好处在于：cancel这个方法被封装后，shuttleOrder.cancel()的调用从可读性上要明显优于使用2句setter方法，同时也为将来的逻辑扩展预留了位置。这也是面向对象的一种实践。 注释规约注释规约的内容比较多，这里也仅挑选一些具有代表性的进行解读12345671.8.5 所有的枚举类型字段必须要有注释，说明每个数据项的用途1.8.6 与其&quot;半吊子&quot;英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可1.8.8 注释掉的代码尽量要配合说明，而不是简单的注释掉1.8.10 好的命名、代码结构是自解释的，注释力求精简准确、表达到位 枚举类加注释是非常必要的，因为枚举通常是都是常量的扩展，而常量是需要说明的。 鉴于很多程序员的英语水平，笔者建议英语不够好的程序员直接使用中文写注释。 对于注释掉的代码，笔者的意见是在绝大多数情况下应该直接删除，除非在很短的时间内还有恢复的余地。 有关什么是好的命名和代码结构，什么样的命名能够使得代码做到自解释，笔者将另外撰文进行说明。 数据库规约数据库规约本身并不属于Java规约的范畴，不过阿里的规范中包含了不少数据库规约的内容，所以笔者也同样加以解读。123456789101112133.1.1 是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）3.1 2 表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字3.1.3 表名不使用复数名词3.1.4 禁用保留字3.1.5 唯一索引名为uk_字段名；普通索引名则为idx_字段名3.1.10 表的命名最好是加上业务名称_表的作用3.1.11 库名与应用名称尽量一致 上述规约主要说的是库、表、字段的命名规约。应该说绝大多数的上述规约都是参考项，需要根据实际情况进行调整，我们逐条来说。 有关布尔值的数据库映射，对于使用is_xx进行命名没有异议，对于数据类型是否应该使用tinyint稍有保留，笔者实际上使用bit更多。由于布尔值所对应的Java类型是boolean，所以笔者通常在命名时，利用boolean的默认值特性，对一些常用的命名进行更加严格的规定。比如「是否有效」，命名成为「is_disabled」就要比「is_enabled」来的好。因为 is_disable = false 是绝大多数程序的事实逻辑，这样就可以利用boolean值默认为false的特性。 Java中的绝大多数命名都使用驼峰法，而数据库的命名实际上更加严格。光光小写是不够的，而是要强制使用下划线命名法（主要是因为SQL是大小写不敏感的语言）。笔者在实际工作中经常看到使用驼峰法命名表名或者字段名的，这种基本上属于小学没毕业的行为。 有关表名不能使用复数，不能使用关键字，这些属于比较基础的命名规范，应该遵守。但是笔者在这里提出更为严格的要求：不仅不能使用SQL关键字进行命名，同样不允许使用Java关键字！因为绝大多数情况，数据库字段会被映射到相应的Java对象，如果可以使用Java关键字，那么映射的时候就是自找麻烦了。 最后三条规约属于建议，相信每个公司都有自己独特的规定。比如笔者见过有一些写Oracle出身的程序员，习惯使用tbl_做表名的前缀，使用vw_做视图的前缀。个人觉得这个方面不宜做过多规定，只要团队保持风格整体一致即可。123453.1.6 小数类型为decimal，禁止使用float和double3.1.7 如果存储的字符串长度几乎相等，使用char定长字符串类型3.1.8 varchar是可变长字符串，不预先分配存储空间，长度不要超过5000 这三条主要说的是数据库设计时的类型规约。 除了上述三条之外，在笔者团队另外还会遵守如下几条： 明确日期和时间，日期使用date类型并使用xxDate进行Java字段命名，时间使用date_time类型并使用xxTime进行Java字段命名，以示区分上面这条主要是和日期时间有关的，强制这样的规约，对于提升代码的可读性是有帮助的。 枚举类型在数据库中既可以映射成int，也可以映射成varchar，视实际情况定通常对于排序和检索有强依赖的，枚举类型映射成int比较理想，否则可以映射成varchar。虽然从效率上说，int基本上会强于varchar，但varchar毕竟可读性更好，所以还是应该一分为二来看。12345678910113.1.9 表必备三字段：id, gmt_create, gmt_modified3.1.8 如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率3.1.12 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释3.1.13 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况3.1.14 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表3.1.15 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度 上面的规约主要涉及到一些数据库表设计上的原则。 其中，3.1.8是非常值得大家注意的一点，笔者个人的习惯是对于大字段，拆表的同时，优化SQL，尽可能做到用主键单独取大字段，避免产生效率瓶颈。 而3.1.14是希望提醒一些自视甚高的架构师不要过早的进行过度设计。这里笔者提一点： 对于每一张数据库表的设计，应该预估表在未来若干时间段内的数量，以采取最佳的程序处理措施这里所说的最佳程序处理措施包括并不限于：使用应用级别缓存对数据库进行减压；选取合适的时间点对表进行分库分表；是否进行人为拆表以保证较快的SQL执行等等。 有关3.1.13，我们在有关SQL编写环节还会说到。123456789101112133.2.1 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引3.2.2 超过三个表禁止join3.2.3 在varchar字段上建立索引时，必须指定索引长度3.2.4 页面搜索严禁左模糊或者全模糊3.2.5 如果有order by的场景，请注意利用索引的有序性3.2.7 利用延迟关联或者子查询优化超多分页场景3.2.9 建组合索引的时候，区分度最高的在最左边 上述规约主要讲的是和索引相关的内容。对于这块，笔者不是专业的DBA，所以只是挑了其中和程序开发特别有关的来讲一讲。 比如3.2.2的禁止超过3个表的join，在笔者的团队中，规定更为严格： 禁止超过2个表的join语句出现在程序中其实不许使用join是很多初级程序员非常不能理解的。要说明白这个问题，估计又要长篇大论，笔者会另辟文章进行说明。但这里还是引用一下robbin的观点（笔者表示深刻赞同）： 另外有关严禁使用全模糊查找，建组合索引时，区分度最高的往左放这些原则，在一定程度上会改变我们编写程序的习惯，所以应该时刻注意。12345678910113.3.1 不要使用count(列名)或count(常量)来替代count(*)3.3.5 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句3.3.6 不得使用外键与级联，一切外键概念必须在应用层解决3.3.7 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性3.3.9 in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内3.4.1 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明 上面的这几条属于SQL编写规约。阿里的规范中洋洋洒洒讲了很多条，实际上都是在给程序员提个醒，笔者在这里不在赘述 有关count()的争论，一直有大量的说法。此次阿里的规范总算为count()党找到了SQL标准，应该说也基本为这件事情画上了句号。 有关外键和级联，笔者稍有困惑的是外键。因为按照笔者的理解，外键影响数据库插入的速度应该有限，与外键约束带来的好处相比，或许还是有外键更好一些（有这方面经验的读者可以留言指点迷津）。级联是恶魔，必须禁止。 至于存储过程，或许Oracle出身的DBA会跳出来唱反调了。笔者的观点和阿里相同：存储过程很难移植和维护，应该抛弃。 有关表查询中不许使用 * 作为查询的字段列表，这点或许能够成为规约，但笔者并不十分认同。尤其是对于使用Hibernate作为ORM工具的同学来说，这条规则执行起来有难度。]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程规范]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F5_standard%2Fstandard%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;阿里巴巴开发手册解析]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java 源码库]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F4_code%2F</url>
    <content type="text"><![CDATA[一，框架源码1，spring 源码地址1https://github.com/spring-projects/spring-framework.git 2，mybatis 源码地址1https://github.com/mybatis/mybatis-3.git 二，中间件源码1，dubbo 源码地址1https://github.com/apache/dubbo.git 2，netty 源码地址1https://github.com/netty/netty.git 3，es 源码地址1https://github.com/elastic/elasticsearch.git 三，算法源码1，lucene 源码地址1https://github.com/apache/lucene-solr.git]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔——成功与失败并无绝对]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F2_notes%2Fnotes1%2F</url>
    <content type="text"><![CDATA[&emsp;记得有这样一句话：你所遇见的每一个人成就了你。&emsp;每个人的思想，就是她所看见世界的整合。我从来不想去否定任何人的观点，就算在我看来是多么幼稚也不想，因为我知道，我没有经历过她的人生。就像五年前我还在想 log 可能我一生都用不上，但我还可以活的好好的。现在才明白，凡事都有它独特的价值，五年后的我，看到的太多，变化的太大。&emsp;唯一没变的可能是《我有一个梦想》中的一段话: 尽管眼下困难重重，我依然有一个梦想。或许我的一生都会碌碌无为，但我依然希望将来的自己仍然心怀梦想，照自己的心意走下去。&emsp;成功与失败并无绝对，就像《追忆逝水年华》的作者普鲁斯特，他一度自认为是个彻底的失败者，一生没工作情事不断还是个同性恋，花二十年写了一本没几个人看的小说，但当晚年回首人生，他发现那些难熬的日子才是一生中最美好的时光。因为那些日子造就了他，在这成功与失败之间，我们最需谨记的是还有无数条通向各人所理解的成功。&emsp;&emsp; ——给未来的自己（2013-07-21）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 原理]]></title>
    <url>%2F2019%2F07%2F01%2F2%2F2.1.1_jvm%2Fjvm%2F</url>
    <content type="text"><![CDATA[一，自动内存管理机制1，Java 内存区域与内存溢出异常&emsp;1.1 概述&emsp;1.2 运行时数据区域&emsp;1.3 HotSpot 虚拟机对象探秘&emsp;1.4 实战：OutOfMemoryError 异常&emsp;1.5 本章小结 2，垃圾收集器与内存分配策略&emsp;2.1 概述&emsp;2.2 对象&emsp;2.3 垃圾收集算法&emsp;2.4 HotSopt 的算法实现&emsp;2.5 垃圾收集器&emsp;2.6 内存分配与回收策略&emsp;2.7 本章小结 3，虚拟机性能监控与故障处理工具&emsp;3.1 概述&emsp;3.2 JDK 的命令行工具&emsp;3.3 JDK 可视化工具&emsp;3.4 本章小结 4，调优方案分析与实战&emsp;4.1 概述&emsp;4.2 案例分析&emsp;4.3 本章小结 二，虚拟机执行子系统1，类文件结构&emsp;1.1 概述&emsp;1.2 无关性的基石&emsp;1.3 Class 类文件的结构&emsp;1.4 字节码指令简介&emsp;1.5 公有设计和私有实现&emsp;1.6 Class 文件结构的发展&emsp;1.7 本章小结 2，虚拟机类加载机制&emsp;2.1 概述&emsp;2.2 类加载的时机&emsp;2.3 类加载器&emsp;2.4 本章小结 3，虚拟机字节码执行引擎&emsp;3.1 概述&emsp;3.2 运行时栈帧结构&emsp;3.3 方法调用&emsp;3.4 基于栈的字节码解释执行引擎&emsp;3.5 本章小结 4，类加载及执行子系统的案例与实战&emsp;4.1 概述&emsp;4.2 案例分析&emsp;4.3 实战：自己动手实现远程执行功能&emsp;4.4 本章小结 三，程序编译与代码优化1，编译期优化&emsp;1.1 概述&emsp;1.2 Javac 编译器&emsp;1.3 Java 语法糖的味道&emsp;1.4 实战：插入式注解处理器&emsp;1.5 本章小结 2，运行期优化&emsp;2.1 概述&emsp;2.2 HotSpot 虚拟机内的即时编译器&emsp;2.3 编译优化技术&emsp;2.4 Java 与 C/C++ 的编译器对比&emsp;2.5 本章小结 四，高效并发1，Java 内存模型与线程&emsp;1.1 概述&emsp;1.2 硬件的效率与一致性&emsp;1.3 Java 内存模型&emsp;1.4 Java 与 线程&emsp;1.5 本章小结 2，线程安全与锁优化&emsp;2.1 概述&emsp;2.2 线程安全&emsp;2.3 锁优化&emsp;2.4 本章小结]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术积累]]></title>
    <url>%2F2019%2F07%2F01%2F3%2F1_technology%2Ftechnology%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;MySQL百万级数据分页查询及优化&emsp;&emsp;Linux 搭建 socks 服务器（翻墙）&emsp;&emsp;Java 中的那些锁事（转载）]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
</search>
