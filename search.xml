<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Post6]]></title>
    <url>%2F2019%2F06%2F01%2FPost6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Post5]]></title>
    <url>%2F2019%2F06%2F01%2FPost5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Post4]]></title>
    <url>%2F2019%2F06%2F01%2FPost4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL百万级数据分页查询及优化]]></title>
    <url>%2F2019%2F05%2F29%2FPost3%2F</url>
    <content type="text"><![CDATA[方法1: 直接使用数据库提供的SQL语句 语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 LIMIT M,N 适应场景: 适用于数据量较少的情况(元组百/千级) 原因/缺点: 全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3). Limit限制的是从结果集的M位置处取出N条输出,其余抛弃. 方法2: 建立主键或唯一索引, 利用索引(假设每页10条) 语句样式: MySQL中,可用如下方法: SELECT FROM 表名称 WHERE id_pk &gt; (pageNum10) LIMIT M 适应场景: 适用于数据量多的情况(元组数上万) 原因: 索引扫描,速度会很快. 有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法3 方法3: 基于索引再排序 语句样式: MySQL中,可用如下方法: SELECT FROM 表名称 WHERE id_pk &gt; (pageNum10) ORDER BY id_pk ASC LIMIT M 适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1) 原因: 索引扫描,速度会很快. 但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待…). 方法4: 基于索引使用prepare 第一个问号表示pageNum，第二个？表示每页元组数 语句样式: MySQL中,可用如下方法: PREPARE stmt_name FROM SELECT FROM 表名称 WHERE id_pk &gt; (？ ？) ORDER BY id_pk ASC LIMIT M 适应场景: 大数据量 原因: 索引扫描,速度会很快. prepare语句又比一般的查询语句快一点。 方法5: 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描 比如: 读第1000到1019行元组(pk是主键/唯一键). SELECT * FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20 方法6: 利用”子查询/连接+索引”快速定位元组的位置,然后再读取元组. 比如(id是主键/唯一键,蓝色字体时变量) 利用子查询示例: SELECT FROM your_table WHERE id &lt;=(SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize ORDER BY id descLIMIT $pagesize 利用连接示例: SELECT FROM your_table AS t1JOIN (SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize AS t2WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize; mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。 测试实验 直接用limit start, count分页语句， 也是我程序中用的方法： select * from product limit start, count 当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。 如下： select from product limit 10, 20 0.016秒select from product limit 100, 20 0.016秒select from product limit 1000, 20 0.047秒select from product limit 10000, 20 0.094秒 我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一般左右） select * from product limit 400000, 20 3.229秒 再看我们取最后一页记录的时间 select * from product limit 866613, 20 37.44秒 像这种分页最大的页码页显然这种时间是无法忍受的。 从中我们也能总结出两件事情： limit语句的查询时间与起始记录的位置成正比 mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。 对limit分页问题的性能优化方法 利用表的覆盖索引来加速分页查询我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。 因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。 在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何。 这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下： select id from product limit 866613, 20 0.2秒 相对于查询了所有列的37.44秒，提升了大概100多倍的速度 那么如果我们也要查询所有列，有两种方法，一种是id&gt;=的形式，另一种就是利用join，看下实际情况： SELECT * FROM product WHERE ID &gt; =(select id from product limit 866613, 1) limit 20 查询时间为0.2秒！ 另一种写法 SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id 查询时间也很短！ 复合索引优化方法 MySql 性能到底能有多高？MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。 用事实说话，看例子： 数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用硬1.6G。 OK ,看下面这条sql语句： select id,title from collect limit 1000,10; 很快；基本上0.01秒就OK，再看下面的 select id,title from collect limit 90000,10; 从9万条开始分页，结果？ 8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句: select id from collect order by id limit 90000,10; 很快，0.04秒就OK。 为什么？因为用了id主键做索引当然快。网上的改法是： select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10; 这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句 select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！ 到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接 select id from collect where vtype=1 limit 1000,10; 是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。 从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下： 建一个索引表： t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。 是否可行呢？实验下就知道了。 10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用 select id from t where vtype=1 order by id limit 90000,10; 很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？ 错！因为我们的limit还是9万，所以快。给个大的，90万开始 select id from t where vtype=1 order by id limit 900000,10; 看看结果，时间是1-2秒！why ? 分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！ 难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？ 答案是： NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！ 好了，我们的测试又回到 collect表，开始测试结论是： 30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！ 答案就是：复合索引！ 有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？ 开始的 select id from collect order by id limit 90000,10; 这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。 然后测试 select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！ 再测试: select id ,title from collect where vtype=1 limit 90000,10; 非常遗憾，8-9秒，没走search索引！ 再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。 综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！ 完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Ioc 原理]]></title>
    <url>%2F2019%2F05%2F29%2FPost2%2F</url>
    <content type="text"><![CDATA[This is a test.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring 简介]]></title>
    <url>%2F2019%2F05%2F29%2FPost1%2F</url>
    <content type="text"><![CDATA[一切都是从Bean开始的在1996年，Java还只是一个新兴的、初出茅庐的编程语言。人们之所以关注她仅仅是因为，可以使用Java的Applet来开发Web应用。但这些开发者很快就发现这个新兴的语言还能做更多的事情。与之前的所有语言不同，Java让模块化构建复杂的系统成为可能（当时的软件行业虽然在业务上突飞猛进，但当时开发用的是传统的面向过程开发思想，软件的开发效率一直踟蹰不前。伴随着业务复杂性的不断加深，开发也变得越发困难。其实，当时也是面向对象思想飞速发展的时期，她在80年代末被提出，成熟于90年代，现今大多数编程语言都是面向对象的，当然这是后话了）。他们为Applet而来，为组件化而留。这便是最早的Java。 同样在这一年的12月，Sun公司发布了当时还名不见经传但后来人尽皆知的JavaBean 1.00-A规范。早期的JavaBean规范针对于Java，她定义了软件组件模型。这个规范规定了一整套编码策略，使简单的Java对象不仅可以被重用，而且还可以轻松地构建更为复杂的应用。尽管JavaBean最初是为重用应用组件而设计的，但当时他们却是主要用作构建窗体控件，毕竟在PC时代那才是主流。但相比于当时正如日中天的Delphi、VB和C++，他看起来还是太简易了，以至于无法胜任任何&quot;实际的&quot;工作。 复杂的应用通常需要诸如事物、安全、分布式等服务的支持，但JavaBean并未直接提供。所以到了1998年3月，Sun发布了EJB 1.0规范，该规范把Java组件的设计理念延伸到了服务器端，并提供了许多必须的企业级服务，但他也不再像早期的JavaBean那么简单了。实际上，除了名字，EJB Bean已经和JavaBean 没有任何关系了。 尽管现实中有很多系统是基于EJB构建的，但EJB从来没有实现它最初的设想：简化开发。EJB的声明式编程模型的确简化了很多基础架构层面的开发，例如事务和安全；但另一方面EJB在部署描述符和配套代码实现等方面变得异常复杂。随着时间的推移，很多开发者对EJB已经不再抱有幻想，开始寻求更简洁的方法。 现在Java组件开发理念重新回归正轨。新的编程技术AOP和DI的不断出现，他们为JavaBean提供了之前EJB才能拥有的强大功能。这些技术为POJO提供了类似EJB的声明式编程模型，而没有引入任何EJB的复杂性。当简单的JavaBean足以胜任时，人们便不愿编写笨重的EJB组件了。 客观地讲，EJB的发展甚至促进了基于POJO的编程模型。引入新的理念，最新的EJB规范相比之前的规范有了前所未有的简化，但对很多开发者而言，这一切的一切都来得太迟了。到了EJB 3规范发布时，其他基于POJO的开发架构已经成为事实的标准了，而Spring框架也是在这样的大环境下出现的。 代码简洁之路 Rod Johnson的思考 Rod Johnson这位澳大利亚的Java大师，很难想象，他除了在悉尼大学获得计算机学士学位以外还获得了音乐的博士学位，或许正是他音乐的细胞成就了Spring独特简约和优雅。他在1996年就踏足Java开发，并且在C++方面也已经有了很深厚的造诣。他常年从事保险、银行等企业的开发，是一个一切从现实出发的设计者以及勇敢的创新者。 Rod Johnson在2002年编著的《Expert One-to-One J2EE Design and Development》一书中，对EJB框架的臃肿、低效、脱离现实等种种现状提出了质疑，并积极寻求革新之道。以此书为指导思想，他编写了interface21框架，这是一个力图冲破Java EE传统开发困境，从实际需求出发，着眼于轻便、灵巧，易于开发、测试和部署的轻量级开发框架。Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了Spring 1.0正式版。同年他又推出了另一部堪称经典的力作《Expert One-to-One J2EE Development without EJB》，该书在Java世界掀起了轩然大波，不断地改变着Java开发者程序设计和开发的思考方式。在该书中，作者根据自己多年丰富的实践经验，对EJB的各项笨重臃肿的结构进行了逐一的分析和否定，并分别以简洁实用的方法代替。可以说，这本书中的代码诞生了Spring Framework。借此，Rod Johnson也奠定了他在Java世界中大师级人物的地位。 设计伊始 Spring 是为解决企业级应用开发的复杂性而设计，她可以做很多事。但归根到底支撑Spring的仅仅是少许的基本理念，而所有地这些的基本理念都能可以追溯到一个最根本的使命：简化开发。这是一个郑重的承诺，其实许多框架都声称在某些方面做了简化。 而Spring则立志于全方面的简化Java开发。对此，她主要采取了4个关键策略： 1，基于POJO的轻量级和最小侵入性编程； 2，通过依赖注入和面向接口松耦合； 3，基于切面和惯性进行声明式编程； 4，通过切面和模板减少样板式代码； 而他主要是通过：面向Bean、依赖注入以及面向切面这三种方式来达成的。 面向Bean Spring 是面向 Bean 的编程（Bean Oriented Programming, BOP），Bean 在 Spring 中才是真正的主角。Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，Spring 中没有 Bean 也就没有 Spring 存在的意义。Spring 提供了 IoC容器通过配置文件或者注解的方式来管理对象之间的依赖关系。 控制反转( 其中最常见的方式叫做依赖注入（Dependency Injection，DI），还有一种方式叫“依赖查找”（Dependency Lookup，DL），她在C++、Java、PHP以及.NET中都运用。在最早的Spring中是包含有依赖注入方法和依赖查询的，但因为依赖查询使用频率过低，不久就被Spring移除了，所以在Spring中控制反转也被称作依赖注入)，她的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IoC容器） 负责将这些联系在一起。 在典型的 IoC场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。 依赖注入 Spring 设计的核心 org.springframework.beans 包（架构核心是org.springframework.core包），它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 BeanFactory 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。 BeanFactory 支持两个对象模型。 1，单例：模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。 2，原型：模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。 bean 工厂的概念是 Spring 作为 IoC容器的基础。IoC则将处理事情的责任从应用程序代码转移到框架。 面向切面 面向切面编程，即 Aop，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。Aop的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。 Aop和 IoC是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 Aop方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring Aop编写的应用程序代码是松散耦合的。 Aop的功能完全集成到了 Spring 事务管理、日志和其他各种特性的上下文中。 俯瞰Spring源码架构系统架构 Spring 总共大约有20个模块，由1300多个不同的文件构成。而这些组件被分别整合在核心容器（Core Container）、Aop（Aspect Oriented Programming）和设备支持（Instrmentation）、数据访问及集成（Data Access/Integeration）、Web、报文发送（Messaging）、Test，6个模块集合中。 以下是 Spring 4 的系统架构图。 组成 Spring 框架的每个模块集合或者模块都可以单独存在，也可以一个或多个模块联合实现。每个模块的组成和功能如下： 1.核心容器：由spring-beans、spring-core、spring-context和spring-expression（Spring Expression Language, SpEL） 4个模块组成。 spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control, IoC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是Spring框架中的核心接口，它是工厂模式的具体实现。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-contest模块构架于核心模块之上，他扩展了BeanFactory，为她添加了Bean生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext是该模块的核心接口，她是 BeanFactory 的超类，与 BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。 spring-expression模块是统一表达式语言（unified EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计，他可以非常方便地同Spring IoC进行交互。 2.Aop和设备支持：由spring-aop、spring-aspects和spring-instrumentation 3个模块组成。 spring-aop是Spring的另一个核心模块，是Aop主要的实现模块。作为继OOP后，对程序员影响最大的编程思想之一，Aop极大地开拓了人们对于编程的思路。在Spring中，他是以JVM的动态代理技术为基础，然后设计出了一系列的Aop横切实现，比如前置通知、返回通知、异常通知等，同时，Pointcut接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。 spring-aspects模块集成自AspectJ框架，主要是为Spring Aop提供多种Aop实现方法。 spring-instrumentation模块是基于JAVA SE中的&quot;java.lang.instrument&quot;进行设计的，应该算是Aop的一个支援模块，主要作用是在JVM启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现Aop的功能。在分类里，我把他分在了Aop模块下，在Spring 官方文档里对这个地方也有点含糊不清，这里是纯个人观点。 3.数据访问及集成：由spring-jdbc、spring-tx、spring-orm、spring-jms和spring-oxm 5个模块组成。 spring-jdbc模块是Spring 提供的JDBC抽象框架的主要实现模块，用于简化Spring JDBC。主要是提供JDBC模板方式、关系数据库对象化方式、SimpleJdbc方式、事务管理来简化JDBC编程，主要实现类是JdbcTemplate、SimpleJdbcTemplate以及NamedParameterJdbcTemplate。 spring-tx模块是Spring JDBC事务控制实现模块。使用Spring框架，它对事务做了很好的封装，通过它的Aop配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用JDBC事务控制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用Spring JDBC事务控制时，应该注意其特殊性。 spring-orm模块是ORM框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和 Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。 spring-jms模块（Java Messaging Service）能够发送和接受信息，自Spring Framework 4.1以后，他还提供了对spring-messaging模块的支撑。 spring-oxm模块主要提供一个抽象层以支撑OXM（OXM是Object-to-XML-Mapping的缩写，它是一个O/M-mapper，将java对象映射成XML数据，或者将XML数据映射成java对象），例如：JAXB, Castor, XMLBeans, JiBX 和 XStream等。 4.Web：由spring-web、spring-webmvc、spring-websocket和spring-webmvc-portlet 4个模块组成。 spring-web模块为Spring提供了最基础Web支持，主要建立于核心容器之上，通过Servlet或者Listeners来初始化IoC容器，也包含一些与Web相关的支持。 spring-webmvc模块众所周知是一个的Web-Servlet模块，实现了Spring MVC（model-view-controller）的Web应用。 spring-websocket模块主要是与Web前端的全双工通讯的协议。（资料缺乏，这是个人理解） spring-webmvc-portlet模块是知名的Web-Portlets模块（Portlets在Web门户上管理和显示的可插拔的用户界面组件。Portlet产生可以聚合到门户页面中的标记语言代码的片段，如HTML，XML等），主要是为SpringMVC提供Portlets组件支持。 5.报文发送：即spring-messaging模块。 spring-messaging是Spring4 新加入的一个模块，主要职责是为Spring 框架集成一些基础的报文传送应用。 6.Test：即spring-test模块。 spring-test模块主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。 依赖关系 该图是SPRING 3.2.X 的包结构，可以从中清楚看出 Spring 各个模块之间的依赖关系。 从图中可以看出，IoC 的实现包 spring-beans 和 AOP 的实现包 spring-aop 是整个框架的基础，而 spring-core 则是整个框架的核心，基础的功能都在这三个包里。 在此基础之上，spring-context 提供上下文环境，为各个模块提供粘合作用。 在 spring-context 基础之上提供了 spring-tx 和 spring-orm包，而web部分的功能，都是要依赖spring-web来实现的。 由于struts框架自身的Bug一直没有修复，以及Spring MVC 已经足够强大，所以在最新的spring 4 中已经移除了 spring-struts 模块。 如果你想加入spring源码的学习，笔者的建议是从spring-core入手，其次是spring-beans和spring-aop，随后是spring-context，再其次是spring-tx和spring-orm，最后是spring-web和其他部分。 闲言小叙框架小结 笔者将Spring的内部设计与操作系统 kernel（Linux内核）的设计方法进行类比，希望借此能更形象的说明Spring体系。 Spring体系的核心是IoC和Aop模块。对于kernel而言，进程调度器就是其关键部位，kernel通过“进程”这个概念来抽象物理的计算资源，同时通过调度算法的设计来实现对计算资源的高效使用。而对于Spring来说，也是一样的，一方面通过IoC容器来进行POJO对象管理，以及对他们进行松耦合处理，同时也让信息资源可以用最简单的Java 语言来抽象和描述;另一方面，可以通过Aop来增强服务的功能。 另外，在Spring体系中，Spring简化了Java EE所进行的开发，这种简化是指我们能够在不EJB这么厚重的环境中使用Java EE的基本服务——为应用开发服务提供了许多即开即用的系统组件合服务，这些服务涵盖了Java EE各个基本服务，对于其他的服务，也可以根据使用情况动态扩展到Spring体系中。基本来说，Spring体系中已经涵盖了Java EE中经常用到的许多服务，比如事务处理、Web MVC、JDBC、ORM、远程调用，这些服务的价值是不可忽视的，就像kernel如果没有实现许多驱动，那Linux对用户而言也是没有任何价值的。Spring通过自己的努力，提供了这些看起来不起眼，但对推广起着关键作用的部分，从而构建起了一个丰富的生态圈。其实，这也是interface21和Spring之间的区别。 和Linux一样，作为一个开源项目。其开源的特性也深深影响了Spring体系的设计，在发展的过程中，其自身也吸收了不少好的社区项目，比如Spring的Security框架就是来源于社区Acegi,这个框架的原意是为Spring设计一个安全框架，让Spring应用更方便地处理一些安全性的问题，但慢慢的被Spring吸收，成为Spring的一个子项目。 太史公曰 笔者坦言，文中的观点建立于大量地书籍、博客、英文资料以及笔者亲身经历之上，其实中间有不少是他人观点和创意，甚至有很多就是原文或者间接的翻译。但笔者认为借鉴他人观点和创意并不可耻，毕加索说过，拙工偷，巧匠盗，但如何将他人的创意有机的结合为一个整体，这就完全看个人的品味了。 本篇是带你走入Spring世界，主要是着眼于架构设计和源码角度编写，其实这也是笔者的Spring 源码分析的写作计划，笔者将她分为了四个部分总共八篇，第一部分是本文主要介绍Spring源码框架，其次是第二部分源码分析第一阶段主要分两篇主要介绍Spring的核心容器和Aop，再其次是源码分析第二阶段分为四篇主要介绍数据访问及集成、Web、报文发送以及Test，最后是一篇总纲。慢工出细活，笔者预计会在一至三个月内编写完一篇，全部完成，可能会花费半年到二年时间。很长对吧，但对于独具匠心的Spring 框架，笔者认为这一切都是值得的。当然笔者也希望，自己能从中得出启示，从而开发出新的东西，毕竟创造的乐趣远远大于使用的乐趣。 最后笔者声明，笔者的初衷是编写笔者对Spring源码分析的总结，平时的兴趣也仅仅在于源码分析、后台以及系统架构。 ——水门 写于2016年01月]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
</search>
