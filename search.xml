<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2020%2F01%2F01%2Fnotes%2Fnotes%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;勿忘初心&emsp;&emsp;追求简约的设计&emsp;&emsp;成功与失败并无绝对]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔——勿忘初心]]></title>
    <url>%2F2020%2F01%2F01%2Fnotes%2Fnotes3%2F</url>
    <content type="text"><![CDATA[&emsp;我一直很想表达一种时代精神：努力生活，努力前进，朝气蓬勃，年轻的活力。&emsp;爱自己所做的事业，也相信一定会继续进步，就像过去的其他人一样。大家都有一个从不成熟到成熟的过程，当你工作十年，你的技巧会更丰富。&emsp;但最重要的是不要忘记了你的初心，就是那份最纯粹的快乐。&emsp;&emsp; ——水门写于杭州（2020-01-29）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔——追求简约的设计]]></title>
    <url>%2F2020%2F01%2F01%2Fnotes%2Fnotes2%2F</url>
    <content type="text"><![CDATA[&emsp;软件是必然变化的，变化是常态；有变化就需要维护，随着时间的推移，维护成本必然会远远超过开发成本，占据整个软件成本的⼤半，因此，在软件开发中，降低维护成本是重中之重的事情，而维护成本正⽐于系统的复杂程度，因此想要降低维护成本，系统就应当追求简单而清晰的设计。&emsp;而简洁，是我们所追求的。代码越简洁，未来做改动的难度就越低，测试也会越准确，对于软件性能也就会越有把握。但简洁并不等于少，⽽是没有多余的东⻄，同时，简洁也是相对的，因为变化从来都是不可能避免的，⼀味杜绝是错误思路，唯⼀可⾏的⽅式是将变化的范围限定在⼀个尽可能⼩的范围内，换句话说就是好的设计能尽可能适应外部尽可能多的变化，同时软件⾃身的变化尽可能的少。&emsp;说到设计，其实程序员也是设计师，与其他⾏业⼀样，软件设计本身也是有科学的，尽管，科学并不等于全知全能。但依然是有章可循的，它们可以被认识，可以被理解。永恒不变的，也是最基本的事实，⽽且确实可⾏。只是很可惜，当今的软件开发⾮常复杂，整个软件⾏业的整体状态是⽅法众多，⽽且存在着彼此的⽭盾却各有道理的观点，这就说明整个软件管理的基本规律尚未被认识，也就是说真正的科学是缺失的。所以，现实中，技术决策的好坏，更多的是来源于主要决策者的智⼒、胆识与经验。&emsp;&emsp; ——水门写于杭州（2017-09-03）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>软件编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔——成功与失败并无绝对]]></title>
    <url>%2F2020%2F01%2F01%2Fnotes%2Fnotes1%2F</url>
    <content type="text"><![CDATA[&emsp;记得有这样一句话：你所遇见的每一个人成就了你。&emsp;每个人的思想，就是她所看见世界的整合。我从来不想去否定任何人的观点，就算在我看来是多么幼稚也不想，因为我知道，我没有经历过她的人生。就像五年前我还在想 log 可能我一生都用不上，但我还可以活的好好的。现在才明白，凡事都有它独特的价值，五年后的我，看到的太多，变化的太大。&emsp;唯一没变的可能是《我有一个梦想》中的一段话: 尽管眼下困难重重，我依然有一个梦想。或许我的一生都会碌碌无为，但我依然希望将来的自己仍然心怀梦想，照自己的心意走下去。&emsp;成功与失败并无绝对，就像《追忆逝水年华》的作者普鲁斯特，他一度自认为是个彻底的失败者，一生没工作情事不断还是个同性恋，花二十年写了一本没几个人看的小说，但当晚年回首人生，他发现那些难熬的日子才是一生中最美好的时光。因为那些日子造就了他，在这成功与失败之间，我们最需谨记的是还有无数条通向各人所理解的成功。&emsp;&emsp; ——给未来的自己（2013-07-21）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fcoding%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;jvm 原理&emsp;&emsp;Java 并发&emsp;&emsp;技术积累]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机原理]]></title>
    <url>%2F2019%2F07%2F01%2Fcomputer%2Fcomputer%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;分布式系统]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学]]></title>
    <url>%2F2019%2F07%2F01%2Fmath%2Fmath%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 简介 2 基本数学2.1 基本思想&emsp; 2.1.1 二进制&emsp; 2.1.2 取余&emsp; 2.1.3 迭代法&emsp; 2.1.4 数学归纳法&emsp; 2.1.5 递归&emsp; 2.1.6 排序&emsp; 2.1.7 组合&emsp; 2.1.8 动态规划&emsp; 2.1.9 树&emsp; 2.1.10 图&emsp; 2.1.11 总结 2.2 数据结构与算法&emsp; 2.2.1 时间和空间复杂度 2.3 常用数据结构&emsp; 2.3.1 数组&emsp; 2.3.2 链表（LRU 算法）&emsp; 2.3.3 栈&emsp; 2.3.4 队列&emsp; 2.3.5 离散表&emsp; 2.3.6 二叉树&emsp;&emsp; 1) 二叉树&emsp;&emsp; 2) B- 树&emsp;&emsp; 3) B+ 树&emsp;&emsp; 4) 红黑树&emsp; 2.3.7 堆&emsp; 2.3.8 跳表&emsp; 2.3.9 图&emsp; 2.3.10 Trie 树&emsp; 2.4.11 总结 2.4 常用算法&emsp; 2.4.1 递归&emsp; 2.4.2 排序&emsp; 2.4.3 二分查找&emsp; 2.4.4 搜索&emsp; 2.4.5 哈希算法&emsp; 2.4.6 贪心算法&emsp; 2.4.7 分治算法&emsp; 2.4.8 回溯算法&emsp; 2.4.9 动态规划&emsp; 2.4.10 匹配算法&emsp; 2.4.11 总结 3 高等数学3.1 线性代数&emsp; 3.1.1 线性代数应用&emsp; 3.1.2 向量空间（可用于大数据检索）&emsp; 3.1.3 文本检索（可用于自然语言）&emsp; 3.1.4 矩阵（可用于推荐算法）&emsp; 3.1.5 线性回归（可用于机器学习）&emsp; 3.1.6 PAC 主成分分析（可用于机器学习）&emsp; 3.1.7 奇异值分解&emsp; 3.1.8 总结 3.2 统计数学&emsp; 3.2.1 概率与统计&emsp; 3.2.2 概率基础&emsp; 3.2.3 朴素贝叶斯（可用于过滤垃圾短信）&emsp; 3.2.4 文本分类（可用于潜在语义分析）&emsp; 3.2.5 文本聚类（可用于潜在语义分析）&emsp; 3.2.6 语言模型（可用于机器学习）&emsp; 3.2.7 马贝尔科夫链（可用于机器学习）&emsp; 3.2.8 信息熵（可用于自然语言）&emsp; 3.2.9 决策树&emsp; 3.2.10 熵、信息增益和卡方（可用于自然语言）&emsp; 3.2.11 规划和标准化（可用于机器学习）&emsp; 3.2.12 特征选择和降维（可用于机器学习）&emsp; 3.2.13 总结 3.3 离散数学3.4 组合数学3.5 高阶数据结构与算法&emsp; 3.5.1 拓扑排序&emsp; 3.5.2 最短路径算法（可用于地图规划）&emsp; 3.5.3 位图（可用于爬虫）&emsp; 3.5.4 统计问题&emsp; 3.5.5 向量空间（可用于推荐和检索）&emsp; 3.5.6 索引（可用于实现各种索引）&emsp; 3.5.7 并行算法&emsp; 3.5.8 总结 4 应用&emsp; 4.1 缓存系统&emsp; 4.2 搜索引擎&emsp; 4.3 推荐系统&emsp; 4.4 总结]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 概述&emsp;1.2 并行编程模型&emsp;1.3 Java 中的锁与线程模型 2 原理2.1 线程&emsp;2.1.1 线程的定义&emsp;2.1.2 线程的层次&emsp;2.1.3 线程创建后的相关行为&emsp;2.1.4 应用程序设计模型与多线程技术&emsp;2.1.5 虚拟环境：虚拟机与虚拟平台 2.2 锁与同步代码块&emsp;2.2.1 并发底层实现原理&emsp;2.2.2 Java 对象头&emsp;2.2.3 锁以及锁升级&emsp;2.2.4 原子操作的实现原理&emsp;2.2.5 综述 2.3 JMM&emsp;2.3.1 简介&emsp;2.3.2 基础&emsp;2.3.3 重排序&emsp;2.3.4 顺序一致性&emsp;2.3.5 volatile 内存模型&emsp;2.3.6 锁 内存模型&emsp;2.3.7 final 内存模型&emsp;2.3.8 happens-before&emsp;2.3.9 综述 2.4 线程安全&emsp;2.4.1 原子性&emsp;2.4.2 锁机制&emsp;2.4.3 可见性&emsp;2.4.4 线程封闭&emsp;2.4.5 不变性&emsp;2.4.6 组合&emsp;2.4.7 综述 2.5 常见并发问题及解决方案&emsp;2.5.1 线程过多&emsp;2.5.2 数据竞争、死锁和活锁&emsp;2.5.3 锁竞争&emsp;2.5.4 非阻塞算法&emsp;2.5.5 线程安全函数和库&emsp;2.5.6 存储问题&emsp;2.5.7 cache 相关&emsp;2.5.8 面向高性能数据组织 3 并行程序设计3.1 多线程基础&emsp;3.1.1 任务分解&emsp;3.1.2 数据分解&emsp;3.1.3 数据流分解&emsp;3.1.4 各种分解方式比较&emsp;3.1.5 综述 3.2 并行程序结构设计&emsp;3.2.1 同步&emsp;3.2.2 临界段&emsp;3.2.3 死锁&emsp;3.2.4 同步原语&emsp;&emsp;1）信号量&emsp;&emsp;2）闭锁&emsp;&emsp;3）条件变量&emsp;3.2.5 消息&emsp;3.2.6 流控&emsp;&emsp;1）栅栏&emsp;&emsp;2）栅障&emsp;3.2.7 其他特征&emsp;3.2.8 综述 3.3 并行程序模式&emsp;3.3.1 单线程模式（Single Threaded Execution Pattern）&emsp;3.3.2 不变模式（Immutable Pattern）&emsp;3.3.3 保护性暂挂模式（Guarded Suspension Pattern）&emsp;3.3.4 回避模式（Balking Pattern）&emsp;3.3.5 生产消费模式（Producer-Consumer Pattern）&emsp;3.3.6 读写锁模式（Read-Write Lock Pattern）&emsp;3.3.7 单线程消息模式（Thread-Per-Message Pattern）&emsp;3.3.8 线程池模式（Worker Thread Pattern） 3.4 并行模型&emsp;3.4.1 Actor 模型 4 应用4.1 并发编程基础&emsp;4.1.1 线程简介&emsp;4.1.2 线程应用&emsp;4.1.3 线程同步&emsp;4.1.4 线程通信&emsp;4.1.5 综述 4.2 并发包&emsp;4.2.1 简介&emsp;4.2.2 锁机制&emsp;4.2.3 原子变量&emsp;4.2.4 并发集合&emsp;4.2.5 非阻塞队列&emsp;4.2.6 阻塞队列&emsp;4.2.7 同步辅助工具&emsp;4.2.8 线程池&emsp;4.2.9 Fork-Join 框架&emsp;4.2.10 Executor 框架&emsp;4.2.11 综述 4.3 并发开源库&emsp;4.3.1 Akka&emsp;4.3.2 RxJava 5 性能与测试&emsp;5.1 避免活跃性危险&emsp;5.2 性能测试&emsp;5.3 性能与可伸缩性&emsp;5.4 综述 6 总结6.1 并发思考&emsp;6.1.1 多线程的安全性问题&emsp;6.1.2 对象共享&emsp;6.1.3 从 Java 内存模型角度理解安全初始化&emsp;6.1.4 从任务到线程：Java 结构化并发应用程序&emsp;6.1.5 驾驭 Java 线程池：定制与扩展&emsp;6.1.6 尝试Java加锁新思路：原子变量和非阻塞同步算法 6.2 未来展望6.3 随笔]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统]]></title>
    <url>%2F2019%2F07%2F01%2Fcomputer%2Fdistributed-system%2Fdistributed-system%2F</url>
    <content type="text"><![CDATA[1 前言&emsp;1.1 简介 2 基本理论2.1 数据一致性&emsp;2.1.1 数据一致性理解&emsp;2.1.2 共识算法&emsp;2.1.3 分布式事务 2.2 高可用&emsp;2.2.1 高可用理解&emsp;2.2.2 负载均衡&emsp;2.2.3 限流&emsp;2.2.4 降级&emsp;2.2.5 补偿 2.3 伸缩性&emsp;2.3.1 有状态与无状态&emsp;2.3.2 高内聚低耦合&emsp;2.3.3 弹性架构&emsp;2.3.4 垂直与水平扩展 2.4 高性能&emsp;2.4.1 缓存&emsp;2.4.2 异步&emsp;2.4.3 阻塞与非阻塞 2.5 易测试&emsp;2.5.1 6个测试方法 2.6 易运维&emsp;2.6.1 监控&emsp;2.6.2 日志系统 3 分布式系统构建3.1 容器技术&emsp;3.1.1 容器原理&emsp;3.1.2 隔离与限制&emsp;3.1.3 镜像&emsp;3.1.4 重识 Docker&emsp;3.1.5 从容器到容器云 3.2 集群搭建3.3 容器网络3.4 调度与资源管理3.5 监控与日志]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.6 尝试Java加锁新思路：原子变量和非阻塞同步算法]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent616%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.5 驾驭 Java 线程池：定制与扩展]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent615%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.4 从任务到线程：Java 结构化并发应用程序]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent614%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.3 从 Java 内存模型角度理解安全初始化]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent613%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.2 对象共享]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent612%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.1.1 多线程的安全性问题]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent611%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.4 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent54%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.3 性能与可伸缩性]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent53%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.2 性能测试]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent52%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1 避免活跃性危险]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent51%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3.2 RxJava]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent432%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3.1 Akka]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent431%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.11 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent4211%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.10 Executor 框架]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent4210%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.9 Fork-Join 框架]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent429%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.8 线程池]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent428%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.7 同步辅助工具]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent427%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.6 阻塞队列]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent426%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.5 非阻塞队列]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent425%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.4 并发集合]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent424%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.3 原子变量]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent423%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.2 锁机制]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent422%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2.1 简介]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent421%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.4 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent414%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.3 线程通信]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent413%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.2 线程应用]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent412%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1.1 线程简介]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent411%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.8 线程池模式（Worker Thread Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent338%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.7 单线程消息模式（Thread-Per-Message Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent337%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.6 读写锁模式（Read-Write Lock Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent336%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.5 生产消费模式（Producer-Consumer Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent335%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.4 回避模式（Balking Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent334%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.3 保护性暂挂模式（Guarded Suspension Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent333%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.2 不变模式（Immutable Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent332%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3.1 单线程模式（Single Threaded Execution Pattern）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent331%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.8 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent328%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.7 其他特征]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent327%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.6 流控]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent326%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.5 消息]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent325%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.4 同步原语]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent324%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.3 死锁]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent323%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.2 临界段]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent322%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2.1 同步]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent321%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.5 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent315%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.4 各种分解方式比较]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent314%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.3 数据流分解]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent313%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.2 数据分解]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent312%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.1 任务分解]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent311%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.8 面向高性能数据组织]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent258%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.7 cache 相关]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent257%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.6 存储问题]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent256%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.5 线程安全函数和库]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent255%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.4 非阻塞算法]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent254%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.3 锁竞争]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent253%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.2 数据竞争、死锁和活锁]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent252%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5.1 线程过多]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent251%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.7 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent247%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.6 组合]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent246%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.5 不变性]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent245%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.4 线程封闭]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent244%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.3 可见性]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent243%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.2 锁机制]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent242%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4.1 原子性]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent241%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.9 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent239%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.8 happens-before]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent238%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.7 final 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent237%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.6 锁 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent236%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.5 volatile 内存模型]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent235%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.4 顺序一致性]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent234%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.3 重排序]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent233%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.2 基础]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent232%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.1 简介]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent231%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.5 综述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent225%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.4 原子操作的实现原理]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent224%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.3 锁以及锁升级]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent223%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.2 Java 对象头]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent222%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.1 并发底层实现原理]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent221%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.5 虚拟环境：虚拟机与虚拟平台]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent215%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.4 应用程序设计模型与多线程技术]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent214%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 线程创建后的相关行为]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent213%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2 线程的层次]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent212%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1 线程定义]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent211%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3 Java 中的锁与线程模型]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent13%2F</url>
    <content type="text"><![CDATA[概述 并发：同一时间应对(dealing with)多件事情的能力 并行：同一时间动手做(doing)多件事情的能力 并发程序的执行通常是不确定的，其结果依赖于事件时序．对于真正的并发程序，不确定性是其与生俱来且伴随始终的属性．而并行程序可能是确定的． 并行架构 位级并行：32位，64位 指令级并行：流水线，乱序，猜测执行 数据级并行: SIMD 任务级并行: 多处理器模型 锁与线程模型D1 线程和锁模型其实是对底层硬件运行过程的形式化，这既是这种模型的最大优点，也是这种模型的最大缺点． 线程和锁模型的三个危害： 竞态条件：代码行为取决于各操作的时序(常用同步来消除竞态条件) 内存可见性: 何时一个线程对内存的修改对另一个线程可见．(锁和volatile来保证可见性) 死锁: 多把锁加锁顺序不当导致各个线程都阻塞而不能继续执行的情况．(避免在持有锁的同时调用自己一无所知的方法,即外星方法．因为这就可能导致在加锁顺序一无所知的情况下使用两把锁而导致发生死锁) Java内存模型如何保证对象初始化是线程安全的?是否必须通过加锁才能在线程之间安全的公开对象? JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化. 新的 JMM 还寻求提供一种新的初始化安全性保证——只要对象是正确构造的（意即不会在构造函数完成之前发布对这个对象的引用，换句话说，不要让其他线程在其他地方能够看见一个构造期间的对象引用），然后所有线程都会看到在构造函数中设置的final字段的值，不管是否使用同步在线程之间传递这个引用。而且，所有可以通过正确构造的对象的final字段可及的变量，如用一个final字段引用的对象的final字段，也保证对其他线程是可见的。这意味着如果final字段包含，比如说对一个 LinkedList 的引用，除了引用的正确的值对于其他线程是可见的外，这个LinkedList在构造时的内容在不同步的情况下，对于其他线程也是可见的。 在讲了如上的这段之后，如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），你希望保证这个对象被其他线程正确的查看，你仍然需要使用同步才行。 “双重检查锁模式”（double-checked locking）以及为什么称之为反模式??? 关键在于：指令重排序导致在多线程情况下，其他线程可能访问到未初始化的对象。 解决方案有二：用volatile修饰instance对象；采用Initialization On Demand Holder idiom方案，即基于类的初始化方案（关键是JVM在初始化类的时候需要获取一把锁）。 选择方法：如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。 D2 ReentranLock 和 Atomic原子类 可以在线程持有锁的时候中断锁 可以设置线程获取锁的超时事件 按任意顺序来获取和释放锁 条件等待 atomic实现lock-free无锁操作． ReentrantLock创建时可以设置一个描述公平性的变量。什么是“公平”的锁？何时适合使用公平锁？使用非公平的锁会怎样？ 如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的；反之，则是非公平锁。 公平锁的性能不如非公平锁——公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配；另一方面，公平锁可以防止“饥饿”情况的产生，在以TPS为唯一指标的场景下，可以考虑使用公平锁。 什么是ReentrantReadWriteLock？它与ReentrantLock有什么区别？适用于什么场景？ ReentrantReadWriteLock的中文名称是读写锁，在多线程场景中，如果没有写线程在操作模板对象，读写锁允许多个读线程同时读。当对于某个数据结构的操作主要是读操作而只有少量的写操作时，就非常适合使用ReentrantReadWriteLock。 什么是“虚假唤醒”（spurious wakeup）？什么时候会发生虚假唤醒？为什么符合规范的代码不用担心虚假唤醒？（1）线程有可能在没有调用过notify()和notifyAll()的情况下醒来；（2）查看如下代码，doWait方法中发生了虚假唤醒——等待线程即使没有收到正确的信号，也能够执行后续的操作。 123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; （3）为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点： 123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 什么是AtomicIntegerFieldUpdater？它与AtomicInteger有什么区别？适用于什么场景？（1）AtomicIntegerFieldUpdater用于保证已经new出来的实例的原子性，AtomicInteger用于构造具备原子性的Integer实例。（2）使用第三方库的时候，如果需要给第三方库提供的对象增加原子性，则使用AtomicIntegerFieldUpdater。 D3总结 使用线程池而不是直接创建线程 使用CopyOnWriteArrayList 避免使用外星方法导致的死锁问题 使用ArrayBlockingQueue来使得生产者和消费者高效协作 ConcurrentHashMap提供了更好的并发访问 问题 Fork/Join和线程池的区别，以及分别适用的场景 ForkJoinPool 相比于ThreadPoolExecutor，还有一个非常重要的特点（优点）在于，ForkJoinPool具有 Work-Stealing （工作窃取）的能力。所谓 Work-Stealing，在 ForkJoinPool 中的实现为：线程池中每个线程都有一个互不影响的任务队列（双端队列），线程每次都从自己的任务队列的队头中取出一个任务来运行；如果某个线程对应的队列已空并且处于空闲状态，而其他线程的队列中还有任务需要处理但是该线程处于工作状态，那么空闲的线程可以从其他线程的队列的队尾取一个任务来帮忙运行 —— 感觉就像是空闲的线程去偷人家的任务来运行一样，所以叫 “工作窃取”。 Work-Stealing 的适用场景是不同的任务的耗时相差比较大，即某些任务需要运行较长时间，而某些任务会很快的运行完成，这种情况下用 Work-Stealing 很合适；但是如果任务的耗时很平均，则此时 Work-Stealing 并不适合，因为窃取任务时也是需要抢占锁的，这会造成额外的时间消耗，而且每个线程维护双端队列也会造成更大的内存消耗。所以ForkJoinPool并不是ThreadPoolExecutor的替代品，而是作为对 ThreadPoolExecutor 的补充。 ThreadPoolExecutor 只能执行 Runnable 和 Callable 任务，而 ForkJoinPool 不仅可以执行 Runnable 和 Callable 任务，还可以执行 Fork/Join 型任务 ForkJoinTask 从而满足并行地实现分治算法的需要； ThreadPoolExecutor 中任务的执行顺序是按照其在共享队列中的顺序来执行的，所以后面的任务需要等待前面任务执行完毕后才能执行，而 ForkJoinPool 每个线程有自己的任务队列，并在此基础上实现了 Work-Stealing 的功能，使得在某些情况下 ForkJoinPool 能更大程度的提高并发效率。 CountDownLatch 和 CyclicBarrier 的区别?? CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. 从javadoc的描述可以得出： CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行； CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。 线程和锁模型优缺点优点 线程和锁模型更接近于本质– 近似于对硬件工作方式的形式化，正确使用时候，效率很高．而且也能解决从小到大不同粒度的问题． 大多数语言支持． 缺点 没有为并行提供直接的支持，不支持分布式内存 难于测试，很多时候我们并不知道自己在坑中，bug难以重现． 可维护性较差 基本规则 访问共享变量需要同步 获取多把锁时候需要按照全局固定的顺序 持有锁的时候避免调用外星方法]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 并行编程模型]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent12%2F</url>
    <content type="text"><![CDATA[1 并行编程模型分类在计算领域，并行编程模型是并行计算机体系架构的一种抽象，它便于编程人员在程序中编写算法及其组合。一个编程模型的价值可以通过其通用性（generality）来判断，如不同体系架构的一系列不同的问题能否在该模型中很好地表示以及其性能如何，编译后的程序执行效率有多高等。并行编程模型的实现有两种方式，作为已有的语言的一种扩展，通过库的形式来调用，或者作为一种全新的语言。 围绕一个实际的编程模型的共识是重要的，因为它会导致构建出支持该模型的不同的并行计算机，从而提高软件的兼容性。在这种意义上说，编程模型是硬件和软件之间的桥梁。 并行编程模型宽泛的可以分为三类： 进程通信（process interaction） 问题分解（problem decomposition） 隐式并行（parallel Processing） 下面我们简要介绍这三类模型有哪些形式。 1.1 进程通信进程通信涉及并行进程互相通信的机制。最常用的通信形式： 共享内存（shared memory） 消息传递（message passing） 分布式内存（distributed shared memory） 1) 共享内存共享内存是在进程间传递数据的高效方式。在共享内存模型中，并行进程共享它们可以异步读与写的全局地址空间。异步并发访问可能导致竞争条件，和用来避免它们的机制如：锁、信号量和监视器。常规的多核处理器直接支持共享内存，很多并行编程语言和库在设计上利用了它，比如采用Fork-join模型的：Cilk、OpenMP和线程建造块。 2) 消息传递在消息传递模型中，并行进程通过消息传递相互交换数据。这种通信可以时异步的，就是说消息可以在接收者准备好之前发出，或时同步的，就是说消息发出前接收者必须准备好。通信顺序进程（CSP）形式化了使用同步通信通道来连接进程的消息传递，并引出了重要的语言如：Occam、Limbo和Go。与之相对，演员模型使用异步消息传递，并被采用于如下语言的设计中：D、Scala和SALSA。 3) 分布式内存分布式内存指称一类多处理器计算机系统，其中每个处理器都有自己私有的内存，计算任务只能在本地数据上运算，如果需要远程数据，计算任务必须与一个或多个远程处理器通信。在分布式内存系统编程中的关键要点是如何把数据分布到各个内存上；依赖于所解决的问题，数据可以静态分布，也可以在节点间移动；数据可以在需要时移动，也可以事先推入新的节点。 MPI规定了用于分布式内存系统的通信协议，支持点到点通信和集体通信（collective communication）二者。MPI还是消息传递API，带有对其特征在任何实现中必须如何表现的协议和语义规定。MPI的目标是高性能、可伸缩性和可移植性，当前仍是高性能计算领域中统治性的模型。此外还有支持单边通信（one-sided communication）的分区全局地址空间模型。 1.2 问题分解并行程序是由同时运行的进程组成。问题分解涉及所有进程如何被组织起来的方式。问题分解包括二种并行模型： 任务并行模型（task parallelism） 数据并行模型（data parallelism） 1) 任务并行任务并行模型关注进程或线程的执行。这些进程通常表现出独特性，并强调对通信的需求。任务并行是表达消息传递通信的自然方式。任务并行通常对应MPMD编程模型，与SPMD的区别在于适合解决的问题而非执行模型。 2) 数据并行数据并行模型关注进行运算所在的数据集，典型的是正规结构的数组。一组任务将在这些数据上运算，但是单独的处于在不相交的分区中。数据并行通常对应SPMD编程模型，相应执行模型对应费林分类法中的SIMD（例如AVX扩展）或MIMD（例如Xeon Phi），还有GPGPU采用的SIMT（例如NVIDIA Tesla）。 1.3 隐式并行在隐式通信中，进程通信对程序员来说是不可见的，主要由编译器、运行时或硬件负责实现。进程通信是由编译器或者运行时来处理和实现。并发被预置在高级操作子中的领域特定语言（domain-specific language）和函数式编程语言是隐式并行的典型例子，因为无副作用（side-effect）允许非依赖的函数可以并发执行。但是这种并行模式是很难管理的。函数式语言如Concurrent Haskell和Concurrent ML提供了显示管理并行化的功能。 2 并行编程模型的例子这里列出的编程模型是可称为桥接模型的计算机的抽象模型，它提供了在一个机器的物理实现和编程者可获得的这个机器的抽象概念之间的桥梁；换句话说，它意图在硬件和软件工程师之间提供共同的理解层面。成功的编程模型可以在现实中有效的实现并被编程者有效的作为目标；特别是应当有可能用典型的高级语言编译器生成良好的代码。从编程者的角度来看，这种并行编程模型典型的位于OpenMP、OpenACC等之下而在Pthreads、IPC、MPI等之上。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 概述]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fconcurrent%2Fconcurrent11%2F</url>
    <content type="text"><![CDATA[并发计算，简单来说，就是将一个计算任务，分割成几个小的部分，让它们同时被计算，之后再汇整计算结果，以完成任务。它跟并行计算（Parallel computing）与分布式计算，有重叠之处，在概念上不同，但常会让人混淆。 并发计算是一种程序运算的特性，可以被视为是并行运算的进一步抽象，它包涵了时间片这种可以被用来实现虚拟并行运算（Pseudoparallelism）的技术，因此在实际的物理运作中，计算过程可能是并行，或非并行的。 并行计算是指，当并发计算的程序，在机器平台上同时被运行的状况，因此，并行计算是一种机器运算的形式之一。分布式计算（Distributed computing）则是并行计算的一个特例，它采用计算机网络来进行同步。 实现并发程序有许多方式，依编程语言与操作系统的支持，可以用进程，或是线程来实现。它可以运行在单一处理器上，将不同的运行步骤分散在不同时间片中运行，以非并行方式循序运算；它也可以用并行计算来实现，将每个行程指定给处理器组中的某个处理器，以单片机多处理器平台，或是透过网络链接的分散平台来实做。 依照硬件与操作系统的支持，并发计算可以在同一个行程中完成，在同一个行程中以多线程来完成，以多个行程来达成，甚至可以分成数个程序来运行。可以用单处理器的循序计算来实现，也可以采并行计算或分布式计算方式实做。 但以并行方式来运作并发程序，并不必然会增进运行效率。因为运行结果可能会因为平台特性而改变，也增加它在设计上的难度。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL百万级数据分页查询及优化]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology5%2F</url>
    <content type="text"><![CDATA[&emsp;方法1: 直接使用数据库提供的SQL语句语句样式: MySQL中,可用如下方法: SELECT FROM 表名称 LIMIT M,N适应场景: 适用于数据量较少的情况(元组百/千级)原因/缺点: 全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3). Limit限制的是从结果集的M位置处取出N条输出,其余抛弃.&emsp;&emsp;方法2: 建立主键或唯一索引, 利用索引(假设每页10条)语句样式: MySQL中,可用如下方法: SELECT FROM表名称: WHERE id_pk &gt; (pageNum10) LIMIT M适应场景: 适用于数据量多的情况(元组数上万)原因: 索引扫描,速度会很快. 有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法3&emsp;&emsp;方法3: 基于索引再排序语句样式: MySQL中,可用如下方法: SELECT FROM表名称 WHERE id_pk &gt; (pageNum10) ORDER BY id_pk ASC LIMIT M适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1)原因: 索引扫描,速度会很快. 但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待…).&emsp;&emsp;方法4: 基于索引使用prepare第一个问号表示pageNum，第二个？表示每页元组数语句样式: MySQL中,可用如下方法: PREPARE stmt_name FROM SELECT FROM 表名称 WHERE id_pk &gt; (？ ？) ORDER BY id_pk ASC LIMIT M适应场景: 大数据量原因: 索引扫描,速度会很快. prepare语句又比一般的查询语句快一点。&emsp;&emsp;方法5: 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描比如: 读第1000到1019行元组(pk是主键/唯一键).SELECT FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20&emsp;&emsp;方法6: 利用”子查询/连接+索引”快速定位元组的位置,然后再读取元组.比如(id是主键/唯一键,蓝色字体时变量)利用子查询示例:SELECT FROM your_table WHERE id &lt;=(SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize ORDER BY id descLIMIT $pagesize 利用连接示例: SELECT FROM your_table AS t1JOIN (SELECT id FROM your_table ORDER BY id desc LIMIT ($page-1)$pagesize AS t2WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize; mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。 测试实验 直接用limit start, count分页语句， 也是我程序中用的方法： select * from product limit start, count 当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。 如下： select from product limit 10, 20 0.016秒select from product limit 100, 20 0.016秒select from product limit 1000, 20 0.047秒select from product limit 10000, 20 0.094秒 我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一般左右） select * from product limit 400000, 20 3.229秒 再看我们取最后一页记录的时间 select * from product limit 866613, 20 37.44秒 像这种分页最大的页码页显然这种时间是无法忍受的。 从中我们也能总结出两件事情： limit语句的查询时间与起始记录的位置成正比 mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。 对limit分页问题的性能优化方法 利用表的覆盖索引来加速分页查询我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。 因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。 在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何。 这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下： select id from product limit 866613, 20 0.2秒 相对于查询了所有列的37.44秒，提升了大概100多倍的速度 那么如果我们也要查询所有列，有两种方法，一种是id&gt;=的形式，另一种就是利用join，看下实际情况： SELECT * FROM product WHERE ID &gt; =(select id from product limit 866613, 1) limit 20 查询时间为0.2秒！ 另一种写法 SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id 查询时间也很短！ 复合索引优化方法 MySql 性能到底能有多高？MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。 用事实说话，看例子： 数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用硬1.6G。 OK ,看下面这条sql语句： select id,title from collect limit 1000,10; 很快；基本上0.01秒就OK，再看下面的 select id,title from collect limit 90000,10; 从9万条开始分页，结果？ 8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句: select id from collect order by id limit 90000,10; 很快，0.04秒就OK。 为什么？因为用了id主键做索引当然快。网上的改法是： select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10; 这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句 select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！ 到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接 select id from collect where vtype=1 limit 1000,10; 是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。 从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下： 建一个索引表： t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。 是否可行呢？实验下就知道了。 10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用 select id from t where vtype=1 order by id limit 90000,10; 很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？ 错！因为我们的limit还是9万，所以快。给个大的，90万开始 select id from t where vtype=1 order by id limit 900000,10; 看看结果，时间是1-2秒！why ? 分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！ 难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？ 答案是： NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！ 好了，我们的测试又回到 collect表，开始测试结论是： 30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！ 答案就是：复合索引！ 有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？ 开始的 select id from collect order by id limit 90000,10; 这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。 然后测试 select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！ 再测试: select id ,title from collect where vtype=1 limit 90000,10; 非常遗憾，8-9秒，没走search索引！ 再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。 综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！ 完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 搭建 socks 服务器（翻墙）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology4%2F</url>
    <content type="text"><![CDATA[下面笔者将用SS5在亚马逊云服务器上的Linux搭建一台Socks5 Proxy Server（用海外阿里云 也可以）具体过程如下： 一，服务端1、首先，编译安装SS5需要先安装一些依赖组件1yum -y install gcc gcc-c++ automake make pam-devel openldap-devel cyrus-sasl-devel openssl-devel 2、下载SS5最新版本的源代码官网 http://ss5.sourceforge.net/1wget https://nchc.dl.sourceforge.net/project/ss5/ss5/3.8.9-8/ss5-3.8.9-8.tar.gz 3、解压后开始编译安装：12345tar zxvf ./ss5-3.8.9-8.tar.gzcd ss5-3.8.9./configuremakemake install 4、让 SS5 随系统一起启动（建议手动启动）123chmod +x /etc/init.d/ss5chkconfig --add ss5chkconfig --level 345 ss5 on 5、设置 ss5 账号密码在ss5.conf中找到auth和permit两行，按照下面的格式进行修改12vi /etc/opt/ss5/ss5.conf（这是 未设置 账号密码）vi /etc/opt/ss5/ss5.passwd（需要 设置 账号密码） 6、设置 ss5 端口默认使用1080端口，并允许任何人使用，如果要修改默认端口，请修改1vi /etc/sysconfig/ss5 在/etc/sysconfig/ss5这个文件中，添加下面这一行命令，-b后面的参数代表监听的ip地址和端口号12# Add startup option hereSS5_OPTS=&quot; -u root -b 0.0.0.0:10808&quot; 7、ss5 操作123service ss5 start（启动ss5）service ss5 status（查看ss5状态）service ss5 stop（停止ss5） 8、检查服务是否启动成功1netstat -an | grep 10808 二，客户端1、Mac 端 2、windows 端需要自己下载 socks 代理]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的那些锁事（转载）]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology3%2F</url>
    <content type="text"><![CDATA[前言Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录： 1. 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 根据从上面的概念描述我们可以发现： 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例： 12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。 CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 CAS算法涉及到三个操作数： 需要读写的内存值 V。进行比较的值 A。要写入的新值 B。当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义： 根据定义我们可以看出各属性的作用： unsafe： 获取并操作内存的数据。valueOffset： 存储value在AtomicInteger中的偏移量。value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码： ------------------------- JDK 8 -------------------------1234567891011121314151617181920212223// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 2. 自旋锁 VS 适应性自旋锁在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。 在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。 首先为什么Synchronized能实现线程同步？ 在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。 Java对象头synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点： 无锁无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁锁升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 整体的锁状态升级流程如下： 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 4. 公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： 接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。 根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。 下面我们来看一下公平锁与非公平锁的加锁方法的源码: 通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 5. 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 6. 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 下图为ReentrantReadWriteLock的部分源码： 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 了解了概念之后我们再来看代码，先看写锁的加锁源码： 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 结语本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。 其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology2%2F</url>
    <content type="text"><![CDATA[一，基础1，代码 代码大全 代码简洁之路 算法设计与分析 设计模式 七周七并发 多核程序设计艺术 2，Java Java 编程思想 Java 并发编程的艺术 Java 多线程编程核心技术 3，数据库 高性能 mysql 4，运维 Linux 命令 二，进阶1，基础 深入理解计算机系统 多处理器编程的艺术 图解性能优化 计算机程序设计的艺术 系统架构 2，代码 重构 设计模式解析 3，Java Effective Java 多线程编程实战 深入理解 JVM 虚拟机 NIO 与 Socket 编程技术指南 spring 源码分析 4，数据库 Mysql 技术内幕 InnoDB 存储引擎 数据库事务处理的艺术 5，中间件 Redis 原理分析 Mq 原理分析 6，分布式 从 Paxos 到 ZooKeeper 分布式理论 7，论文 JSR133 JSP107 The java.util.concurrent Synchronizer Framework A Java Fork/Join Framework 三，高级]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java 源码库]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology1%2F</url>
    <content type="text"><![CDATA[一，框架源码1，spring 源码地址1https://github.com/spring-projects/spring-framework.git 2，mybatis 源码地址1https://github.com/mybatis/mybatis-3.git 二，中间件源码1，dubbo 源码地址1https://github.com/apache/dubbo.git 2，netty 源码地址1https://github.com/netty/netty.git 3，es 源码地址1https://github.com/elastic/elasticsearch.git 三，算法源码1，lucene 源码地址1https://github.com/apache/lucene-solr.git]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 原理]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Fjvm%2Fjvm%2F</url>
    <content type="text"><![CDATA[&emsp;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术积累]]></title>
    <url>%2F2019%2F07%2F01%2Fcoding%2Ftechnology%2Ftechnology%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;MySQL百万级数据分页查询及优化&emsp;&emsp;Linux 搭建 socks 服务器（翻墙）&emsp;&emsp;Java 中的那些锁事（转载）&emsp;&emsp;书单&emsp;&emsp;java 源码库]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
</search>
