<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 并发分析]]></title>
    <url>%2F2019%2F06%2F01%2Fconcurrent%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[1. 简介2. 原理2.1 线程&emsp;2.1.1 线程定义&emsp;2.1.2 线程的层次&emsp;2.1.3 线程创建后的相关行为&emsp;2.1.4 应用程序设计模型与多线程技术&emsp;2.1.5 虚拟环境：虚拟机与虚拟平台 2.2 JMM&emsp;2.2.1 简介&emsp;2.2.2 基础&emsp;2.2.3 重排序&emsp;2.2.4 顺序一致性&emsp;2.2.5 volatile 内存模型&emsp;2.2.6 锁 内存模型&emsp;2.2.7 final 内存模型&emsp;2.2.8 happens-before&emsp;2.2.9 综述 2.3 线程安全&emsp;2.3.1 原子性&emsp;2.3.2 锁机制&emsp;2.3.3 可见性&emsp;2.3.4 线程封闭&emsp;2.3.5 不变性&emsp;2.3.6 组合&emsp;2.3.7 综述 3 设计3.1 多线程设计基础&emsp;3.1.1 任务分解&emsp;3.1.2 数据分解&emsp;3.1.3 数据流分解&emsp;3.1.4 各种分解方式比较&emsp;3.1.5 综述 3.2 并行程序设计结构&emsp;3.2.1 同步&emsp;3.2.2 临界段&emsp;3.2.3 死锁&emsp;3.2.4 同步原语&emsp;&emsp;1）信号量&emsp;&emsp;2）锁&emsp;&emsp;3）条件变量&emsp;3.2.5 消息&emsp;3.2.6 流控&emsp;&emsp;1）栅栏&emsp;&emsp;2）栅障&emsp;3.2.7 其他特征&emsp;3.2.8 综述 3.3 并行程序设计模式&emsp;3.3.1 单线程模式（Single Threaded Execution Pattern）&emsp;3.3.2 不变模式（Immutable Pattern）&emsp;3.3.3 保护性暂挂模式（Guarded Suspension Pattern）&emsp;3.3.4 回避模式（Balking Pattern）&emsp;3.3.5 生产消费模式（Producer-Consumer Pattern）&emsp;3.3.6 读写锁模式（Read-Write Lock Pattern）&emsp;3.3.7 单线程消息模式（Thread-Per-Message Pattern）&emsp;3.3.8 线程池模式（Worker Thread Pattern） 4. 实践4.1 锁与同步代码块&emsp;4.1.1 并发底层实现原理&emsp;4.1.2 Java 对象头&emsp;4.1.3 锁以及锁升级&emsp;4.1.4 原子操作的实现原理&emsp;4.1.5 综述 4.2 并发编程基础&emsp;4.2.1 线程简介&emsp;4.2.2 线程应用&emsp;4.2.3 线程通信&emsp;4.2.4 综述 4.2 并发包&emsp;4.2.1 简介&emsp;4.2.2 锁机制&emsp;4.2.3 原子变量&emsp;4.2.4 并发集合&emsp;4.2.5 非阻塞队列&emsp;4.2.6 阻塞队列&emsp;4.2.7 同步辅助工具&emsp;4.2.8 线程池&emsp;4.2.9 Fork-Join 框架&emsp;4.2.10 Executor 框架&emsp;4.2.11 综述 4.3 并发开源库&emsp;4.3.1 Akka 5. 性能与测试5.1 避免活跃性危险5.2 性能测试5.3 性能与可伸缩性5.4 综述6. 总结]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
